<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>System.Threading</name>
  </assembly>
  <members>
    <member name="T:System.Threading.AbandonedMutexException">
      <summary>Exception levée lorsqu'un thread acquiert un objet <see cref="T:System.Threading.Mutex" /> qu'un autre thread a abandonné en se terminant sans le libérer.</summary>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AbandonedMutexException" /> avec les valeurs par défaut.</summary>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.Int32,System.Threading.WaitHandle)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AbandonedMutexException" /> avec un index spécifié pour le mutex abandonné, le cas échéant, et un objet <see cref="T:System.Threading.Mutex" /> qui représente le mutex.</summary>
      <param name="location">Index du mutex abandonné dans le tableau des handles d'attente si l'exception est levée pour la méthode <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, ou -1 si l'exception est levée pour les méthodes <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> ou <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Objet <see cref="T:System.Threading.Mutex" /> qui représente le mutex abandonné.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AbandonedMutexException" /> avec un message d'erreur spécifié.</summary>
      <param name="message">Message d'erreur qui indique la raison de l'exception.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AbandonedMutexException" /> avec un message d'erreur et une exception interne spécifiés. </summary>
      <param name="message">Message d'erreur qui indique la raison de l'exception.</param>
      <param name="inner">Exception qui constitue la cause de l'exception actuelle.Si le paramètre <paramref name="inner" /> n'est pas null, l'exception en cours est levée dans un bloc catch qui gère l'exception interne.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Exception,System.Int32,System.Threading.WaitHandle)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AbandonedMutexException" /> avec un message d'erreur spécifié, l'exception interne, l'index pour le mutex abandonné, le cas échéant, et un objet <see cref="T:System.Threading.Mutex" /> qui représente le mutex.</summary>
      <param name="message">Message d'erreur qui indique la raison de l'exception.</param>
      <param name="inner">Exception qui constitue la cause de l'exception actuelle.Si le paramètre <paramref name="inner" /> n'est pas null, l'exception en cours est levée dans un bloc catch qui gère l'exception interne.</param>
      <param name="location">Index du mutex abandonné dans le tableau des handles d'attente si l'exception est levée pour la méthode <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, ou -1 si l'exception est levée pour les méthodes <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> ou <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Objet <see cref="T:System.Threading.Mutex" /> qui représente le mutex abandonné.</param>
    </member>
    <member name="M:System.Threading.AbandonedMutexException.#ctor(System.String,System.Int32,System.Threading.WaitHandle)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AbandonedMutexException" /> avec un message d'erreur spécifié, l'index du mutex abandonné, le cas échéant, et le mutex abandonné. </summary>
      <param name="message">Message d'erreur qui indique la raison de l'exception.</param>
      <param name="location">Index du mutex abandonné dans le tableau des handles d'attente si l'exception est levée pour la méthode <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, ou -1 si l'exception est levée pour les méthodes <see cref="Overload:System.Threading.WaitHandle.WaitOne" /> ou <see cref="Overload:System.Threading.WaitHandle.WaitAll" />.</param>
      <param name="handle">Objet <see cref="T:System.Threading.Mutex" /> qui représente le mutex abandonné.</param>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.Mutex">
      <summary>Obtient le mutex abandonné qui a provoqué l'exception, s'il est connu.</summary>
      <returns>Objet <see cref="T:System.Threading.Mutex" /> qui représente le mutex abandonné ou null si les mutex abandonnés n'ont pas pu être identifiés.</returns>
      <filterpriority>1</filterpriority>
    </member>
    <member name="P:System.Threading.AbandonedMutexException.MutexIndex">
      <summary>Obtient l'index du mutex abandonné qui a provoqué l'exception, s'il est connu.</summary>
      <returns>Index, dans le tableau de handles d'attente passés à la méthode <see cref="Overload:System.Threading.WaitHandle.WaitAny" />, de l'objet <see cref="T:System.Threading.Mutex" /> qui représente le mutex abandonné ou -1 si l'index du mutex abandonné n'a pas pu être déterminé.</returns>
      <filterpriority>1</filterpriority>
    </member>
    <member name="T:System.Threading.AsyncLocal`1">
      <summary>Représente les données ambiantes qui sont locales à un flux de contrôle asynchrone donné, par exemple une méthode asynchrone. </summary>
      <typeparam name="T">Type des données ambiantes. </typeparam>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor">
      <summary>Instancie une instance de <see cref="T:System.Threading.AsyncLocal`1" /> qui ne reçoit pas de notifications de modification. </summary>
    </member>
    <member name="M:System.Threading.AsyncLocal`1.#ctor(System.Action{System.Threading.AsyncLocalValueChangedArgs{`0}})">
      <summary>Instancie une instance locale de <see cref="T:System.Threading.AsyncLocal`1" /> qui ne reçoit pas de notifications de modification. </summary>
      <param name="valueChangedHandler">Le délégué est appelé à chaque modification de la valeur actuelle sur n'importe quel thread. </param>
    </member>
    <member name="P:System.Threading.AsyncLocal`1.Value">
      <summary>Obtient ou définit la valeur des données ambiantes. </summary>
      <returns>Valeur des données ambiantes. </returns>
    </member>
    <member name="T:System.Threading.AsyncLocalValueChangedArgs`1">
      <summary>Classe qui fournit les informations de modification des données aux instances de <see cref="T:System.Threading.AsyncLocal`1" /> qui s'inscrivent pour les notifications de modification. </summary>
      <typeparam name="T">Type des données. </typeparam>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.CurrentValue">
      <summary>Obtient la valeur actuelle des données. </summary>
      <returns>Valeur actuelle des données. </returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.PreviousValue">
      <summary>Obtient la valeur précédente des données.</summary>
      <returns>Valeur précédente des données. </returns>
    </member>
    <member name="P:System.Threading.AsyncLocalValueChangedArgs`1.ThreadContextChanged">
      <summary>Retourne une valeur qui indique si la valeur est modifiée en raison d'un changement du contexte d'exécution. </summary>
      <returns>true si la valeur est modifiée en raison d'un changement du contexte d'exécution ; sinon, false. </returns>
    </member>
    <member name="T:System.Threading.AutoResetEvent">
      <summary>Avertit un thread en attente qu'un événement s'est produit.Cette classe ne peut pas être héritée.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.AutoResetEvent.#ctor(System.Boolean)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.AutoResetEvent" /> avec une valeur booléenne indiquant si l'état initial doit être défini à "signalé".</summary>
      <param name="initialState">true pour définir l'état initial à "signalé" ; false pour le définir à "non signalé". </param>
    </member>
    <member name="T:System.Threading.Barrier">
      <summary>Permet à plusieurs tâches de travailler en parallèle de manière coopérative sur un algorithme via plusieurs phases.</summary>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount">Nombre de threads participants.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> est inférieur à 0 ou supérieur à 32,767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.#ctor(System.Int32,System.Action{System.Threading.Barrier})">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Barrier" />.</summary>
      <param name="participantCount">Nombre de threads participants.</param>
      <param name="postPhaseAction">
        <see cref="T:System.Action`1" /> à exécuter après chaque phase. null (nothing en Visual Basic) peut être passé pour indiquer qu'aucune action n'est effectuée.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> est inférieur à 0 ou supérieur à 32,767.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipant">
      <summary>Signale à <see cref="T:System.Threading.Barrier" /> qu'il y aura un participant supplémentaire.</summary>
      <returns>Numéro de la phase du cloisonnement à laquelle les nouveaux participants participeront en premier.</returns>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException">L'ajout d'un participant provoquerait l'augmentation du nombre de participants du cloisonnement au-delà de 32 767.ouLa méthode a été appelée à partir d'une action post-phase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.AddParticipants(System.Int32)">
      <summary>Signale à <see cref="T:System.Threading.Barrier" /> qu'il y aura des participants supplémentaires.</summary>
      <returns>Numéro de la phase du cloisonnement à laquelle les nouveaux participants participeront en premier.</returns>
      <param name="participantCount">Nombre de participants supplémentaires à ajouter au cloisonnement.</param>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> est inférieur à 0.ouL'ajout de participants (<paramref name="participantCount" />) provoquerait l'augmentation du nombre de participants du cloisonnement au-delà de 32 767.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode a été appelée à partir d'une action post-phase.</exception>
    </member>
    <member name="P:System.Threading.Barrier.CurrentPhaseNumber">
      <summary>Obtient le numéro de la phase actuelle du cloisonnement.</summary>
      <returns>Retourne le numéro de la phase actuelle du cloisonnement.</returns>
    </member>
    <member name="M:System.Threading.Barrier.Dispose">
      <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.Barrier" />.</summary>
      <exception cref="T:System.InvalidOperationException">La méthode a été appelée à partir d'une action post-phase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par <see cref="T:System.Threading.Barrier" /> et éventuellement les ressources managées.</summary>
      <param name="disposing">true pour libérer les ressources managées et non managées ; false pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantCount">
      <summary>Obtient le nombre total de participants au cloisonnement.</summary>
      <returns>Retourne le nombre total de participants au cloisonnement.</returns>
    </member>
    <member name="P:System.Threading.Barrier.ParticipantsRemaining">
      <summary>Obtient le nombre de participants au cloisonnement qui n'ont pas encore été signalés dans la phase actuelle.</summary>
      <returns>Retourne le nombre de participants au cloisonnement qui n'ont pas encore été signalés dans la phase actuelle.</returns>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipant">
      <summary>Signale à <see cref="T:System.Threading.Barrier" /> qu'il y aura un participant en moins.</summary>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException">La barrière a déjà 0 participant.ouLa méthode a été appelée à partir d'une action post-phase.</exception>
    </member>
    <member name="M:System.Threading.Barrier.RemoveParticipants(System.Int32)">
      <summary>Signale à <see cref="T:System.Threading.Barrier" /> qu'il y aura moins de participants.</summary>
      <param name="participantCount">Nombre de participants supplémentaires à supprimer du cloisonnement.</param>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="participantCount" /> est inférieur à 0.</exception>
      <exception cref="T:System.InvalidOperationException">La barrière a déjà 0 participant.ouLa méthode a été appelée à partir d'une action post-phase. oule nombre de participant actuel est inférieur au participantCount spécifié</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Le nombre total de participants est inférieur au<paramref name=" participantCount" /> spécifié</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait">
      <summary>Signale qu'un participant a atteint le cloisonnement et qu'il attend que tous les autres participants atteignent également le cloisonnement.</summary>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode a été appelée à partir d'une action post-phase, le cloisonnement comporte actuellement 0 participants, ou il est signalé par un nombre de threads plus important que celui enregistré en tant que participants.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">Si une exception est levée par l'action de post-phase d'un cloisonnement après que tous les threads participants aient appelé SignalAndWait, l'exception sera incluse dans un wrapper dans une BarrierPostPhaseException et levée pour tous les threads participants.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32)">
      <summary>Signale qu'un participant a atteint le cloisonnement et qu'il attend que tous les autres participants atteignent également le cloisonnement, à l'aide d'un entier signé 32 bits pour mesurer le délai d'attente.</summary>
      <returns>si tous les participants ont atteint le cloisonnement dans le délai spécifié ; sinon false.</returns>
      <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" />(-1) pour un délai d'attente infini.</param>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> est un nombre négatif autre que -1, qui représente un délai d'attente infini.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode a été appelée à partir d'une action post-phase, le cloisonnement comporte actuellement 0 participants, ou il est signalé par un nombre de threads plus important que celui enregistré en tant que participants.</exception>
      <exception cref="T:System.Threading.BarrierPostPhaseException">Si une exception est levée par l'action de post-phase d'un cloisonnement après que tous les threads participants aient appelé SignalAndWait, l'exception sera incluse dans un wrapper dans une BarrierPostPhaseException et levée pour tous les threads participants.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Int32,System.Threading.CancellationToken)">
      <summary>Signale qu'un participant a atteint le cloisonnement et qu'il attend que tous les autres participants atteignent également le cloisonnement, à l'aide d'un entier signé 32 bits pour mesurer le délai d'attente, tout en observant un jeton d'annulation.</summary>
      <returns>si tous les participants ont atteint le cloisonnement dans le délai spécifié ; sinon false.</returns>
      <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" />(-1) pour un délai d'attente infini.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> est un nombre négatif autre que -1, qui représente un délai d'attente infini.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode a été appelée à partir d'une action post-phase, le cloisonnement comporte actuellement 0 participants, ou il est signalé par un nombre de threads plus important que celui enregistré en tant que participants.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.Threading.CancellationToken)">
      <summary>Signale qu'un participant a atteint le cloisonnement et qu'il attend que tous les autres participants atteignent également le cloisonnement, tout en observant un jeton d'annulation.</summary>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode a été appelée à partir d'une action post-phase, le cloisonnement comporte actuellement 0 participants, ou il est signalé par un nombre de threads plus important que celui enregistré en tant que participants.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan)">
      <summary>Signale qu'un participant a atteint le cloisonnement et qu'il attend que tous les autres participants atteignent également le cloisonnement, à l'aide d'un objet <see cref="T:System.TimeSpan" /> qui mesure l'intervalle de temps.</summary>
      <returns>true si tous les autres participants ont atteint le cloisonnement ; sinon, false.</returns>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente - 1 millième de seconde, pour attendre indéfiniment.</param>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d'attente infini, ou sa valeur est supérieure à 32 767.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode a été appelée à partir d'une action post-phase, le cloisonnement comporte actuellement 0 participants, ou il est signalé par un nombre de threads plus important que celui enregistré en tant que participants.</exception>
    </member>
    <member name="M:System.Threading.Barrier.SignalAndWait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Signale qu'un participant a atteint le cloisonnement et qu'il attend que tous les autres participants atteignent également le cloisonnement, à l'aide d'un objet <see cref="T:System.TimeSpan" /> qui mesure l'intervalle de temps, tout en observant un jeton d'annulation.</summary>
      <returns>true si tous les autres participants ont atteint le cloisonnement ; sinon, false.</returns>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente - 1 millième de seconde, pour attendre indéfiniment.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> est un nombre négatif autre que -1 milliseconde, qui représente un délai d'attente infini.</exception>
      <exception cref="T:System.InvalidOperationException">La méthode a été appelée à partir d'une action post-phase, le cloisonnement comporte actuellement 0 participants, ou il est signalé par un nombre de threads plus important que celui enregistré en tant que participants.</exception>
    </member>
    <member name="T:System.Threading.BarrierPostPhaseException">
      <summary>L'exception levée lorsque l'action post-phase d'un <see cref="T:System.Threading.Barrier" /> échoue.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.BarrierPostPhaseException" /> avec un message système qui décrit l'erreur.</summary>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.Exception)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.BarrierPostPhaseException" /> avec l'exception interne spécifiée.</summary>
      <param name="innerException">Exception qui constitue la cause de l'exception actuelle.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.BarrierPostPhaseException" /> avec un message spécifié décrivant l'erreur.</summary>
      <param name="message">Message qui décrit l'exception.L'appelant de ce constructeur doit vérifier que cette chaîne a été localisée pour la culture du système en cours.</param>
    </member>
    <member name="M:System.Threading.BarrierPostPhaseException.#ctor(System.String,System.Exception)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.BarrierPostPhaseException" /> avec un message d'erreur spécifié et une référence à l'exception interne ayant provoqué cette exception.</summary>
      <param name="message">Message qui décrit l'exception.L'appelant de ce constructeur doit vérifier que cette chaîne a été localisée pour la culture du système en cours.</param>
      <param name="innerException">Exception qui constitue la cause de l'exception actuelle.Si le paramètre <paramref name="innerException" /> n'est pas null, l'exception en cours est levée dans un bloc catch qui gère l'exception interne.</param>
    </member>
    <member name="T:System.Threading.ContextCallback">
      <summary>Représente une méthode à appeler dans un nouveau contexte.  </summary>
      <param name="state">Objet contenant les informations que la méthode de rappel doit utiliser à chacune de ses exécutions.</param>
      <filterpriority>1</filterpriority>
    </member>
    <member name="T:System.Threading.CountdownEvent">
      <summary>Représente une primitive de synchronisation qui est signalée lorsque son décompte atteint zéro.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.#ctor(System.Int32)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.CountdownEvent" /> à l'aide du décompte spécifié.</summary>
      <param name="initialCount">Nombre de signaux initialement requis pour définir <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="initialCount" /> est inférieur à 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount">
      <summary>Incrémente de un le décompte actuel de <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException">L'instance actuelle est déjà définie.ou<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> est supérieur ou égal à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.AddCount(System.Int32)">
      <summary>Incrémente d'une valeur spécifiée le décompte actuel de <see cref="T:System.Threading.CountdownEvent" />.</summary>
      <param name="signalCount">Valeur d'incrément de <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> est inférieur ou égal à 0.</exception>
      <exception cref="T:System.InvalidOperationException">L'instance actuelle est déjà définie.ou<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> est égal à ou supérieur à <see cref="F:System.Int32.MaxValue" /> une fois le nombre été incrémenté par <paramref name="signalCount." /></exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.CurrentCount">
      <summary>Obtient le nombre de signaux restants requis pour définir l'événement.</summary>
      <returns> Nombre de signaux restants requis pour définir l'événement.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose">
      <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.CountdownEvent" />.</summary>
    </member>
    <member name="M:System.Threading.CountdownEvent.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par <see cref="T:System.Threading.CountdownEvent" /> et éventuellement les ressources managées.</summary>
      <param name="disposing">true pour libérer les ressources managées et non managées ; false pour libérer uniquement les ressources non managées.</param>
    </member>
    <member name="P:System.Threading.CountdownEvent.InitialCount">
      <summary>Obtient le nombre de signaux initialement requis pour définir l'événement.</summary>
      <returns> Nombre de signaux initialement requis pour définir l'événement.</returns>
    </member>
    <member name="P:System.Threading.CountdownEvent.IsSet">
      <summary>Détermine si l'événement est défini.</summary>
      <returns>true si l'événement est défini ; sinon, false.</returns>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset">
      <summary>Réinitialise <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> avec la valeur <see cref="P:System.Threading.CountdownEvent.InitialCount" />.</summary>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Reset(System.Int32)">
      <summary>Définit la propriété <see cref="P:System.Threading.CountdownEvent.InitialCount" /> spécifiée sur la valeur indiquée.</summary>
      <param name="count">Nombre de signaux requis pour définir <see cref="T:System.Threading.CountdownEvent" />.</param>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="count" /> est inférieur à 0.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal">
      <summary>Enregistre un signal avec le <see cref="T:System.Threading.CountdownEvent" />, en décrémentant la valeur de <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</summary>
      <returns>true si le décompte a atteint zéro en raison du signal et que l'événement a été défini ; sinon, false.</returns>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException">L'instance actuelle est déjà définie.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Signal(System.Int32)">
      <summary>Inscrit plusieurs signaux avec <see cref="T:System.Threading.CountdownEvent" />, en décrémentant la valeur de <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> selon la valeur spécifiée.</summary>
      <returns>true si le décompte a atteint zéro en raison des signaux et que l'événement a été défini ; sinon, false.</returns>
      <param name="signalCount">Nombre de signaux à inscrire.</param>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> est inférieur à 1.</exception>
      <exception cref="T:System.InvalidOperationException">L'instance actuelle est déjà définie. - ou - Ou <paramref name="signalCount" /> est supérieur à <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount">
      <summary>Essaie d'incrémenter <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> par un.</summary>
      <returns>true si l'incrémentation a réussi ; sinon, false.Si <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> est déjà à zéro, cette méthode retourne la valeur false.</returns>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.InvalidOperationException">
        <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> est égal à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.TryAddCount(System.Int32)">
      <summary>Essaie d'incrémenter <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> par une valeur spécifiée.</summary>
      <returns>true si l'incrémentation a réussi ; sinon, false.Si <see cref="P:System.Threading.CountdownEvent.CurrentCount" /> est déjà à zéro, la valeur false est retournée.</returns>
      <param name="signalCount">Valeur d'incrément de <see cref="P:System.Threading.CountdownEvent.CurrentCount" />.</param>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="signalCount" /> est inférieur ou égal à 0.</exception>
      <exception cref="T:System.InvalidOperationException">L'instance actuelle est déjà définie.ou<see cref="P:System.Threading.CountdownEvent.CurrentCount" /> + <paramref name="signalCount" /> est supérieur ou égal à  <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait">
      <summary>Bloque le thread actuel jusqu'à ce que <see cref="T:System.Threading.CountdownEvent" /> soit défini.</summary>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32)">
      <summary>Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.CountdownEvent" /> soit défini, à l'aide d'un entier signé 32 bits permettant de mesurer le délai d'attente.</summary>
      <returns>true si <see cref="T:System.Threading.CountdownEvent" /> a été défini ; sinon, false.</returns>
      <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" />(-1) pour un délai d'attente infini.</param>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> est un nombre négatif autre que -1, qui représente un délai d'attente infini.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Int32,System.Threading.CancellationToken)">
      <summary>Bloque le thread actuel jusqu'à ce que <see cref="T:System.Threading.CountdownEvent" /> soit défini, à l'aide d'un entier signé 32 bits permettant de mesurer le délai d'attente, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <returns>true si <see cref="T:System.Threading.CountdownEvent" /> a été défini ; sinon, false.</returns>
      <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" />(-1) pour un délai d'attente infini.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée. - ou - le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> est un nombre négatif autre que -1, qui représente un délai d'attente infini.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.Threading.CancellationToken)">
      <summary>Bloque le thread actuel jusqu'à ce que <see cref="T:System.Threading.CountdownEvent" /> soit défini, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée. - ou - le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan)">
      <summary>Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.CountdownEvent" /> soit défini, à l'aide d'un <see cref="T:System.TimeSpan" /> permettant de mesurer le délai d'attente.</summary>
      <returns>true si <see cref="T:System.Threading.CountdownEvent" /> a été défini ; sinon, false.</returns>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente - 1 millième de seconde, pour attendre indéfiniment.</param>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> est un nombre négatif autre que -1 millisecondes, qui représente un délai d'expiration infini - ou - le délai d'attente est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:System.Threading.CountdownEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.CountdownEvent" /> soit défini, à l'aide d'un <see cref="T:System.TimeSpan" /> permettant de mesurer le délai d'attente, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <returns>true si <see cref="T:System.Threading.CountdownEvent" /> a été défini ; sinon, false.</returns>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente - 1 millième de seconde, pour attendre indéfiniment.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> a été annulé.</exception>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée. - ou - le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a déjà été supprimé.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> est un nombre négatif autre que -1 millisecondes, qui représente un délai d'expiration infini - ou - le délai d'attente est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="P:System.Threading.CountdownEvent.WaitHandle">
      <summary>Obtient un <see cref="T:System.Threading.WaitHandle" /> qui est utilisé pour attendre l'événement à définir.</summary>
      <returns>
        <see cref="T:System.Threading.WaitHandle" /> qui est utilisé pour attendre l'événement à définir.</returns>
      <exception cref="T:System.ObjectDisposedException">L'instance actuelle a déjà été supprimée.</exception>
    </member>
    <member name="T:System.Threading.EventResetMode">
      <summary>Indique si un <see cref="T:System.Threading.EventWaitHandle" /> est réinitialisé automatiquement ou manuellement après la réception d'un signal.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="F:System.Threading.EventResetMode.AutoReset">
      <summary>Une fois signalé, le <see cref="T:System.Threading.EventWaitHandle" /> se réinitialise automatiquement après avoir libéré un seul thread.Si aucun thread n'attend, le <see cref="T:System.Threading.EventWaitHandle" /> conserve l'état signalé jusqu'à ce qu'un thread se bloque et se réinitialise après l'avoir libéré.</summary>
    </member>
    <member name="F:System.Threading.EventResetMode.ManualReset">
      <summary>Lorsqu'il est signalé, le <see cref="T:System.Threading.EventWaitHandle" /> libère tous les threads en attente et conserve l'état signalé jusqu'à sa réinitialisation manuelle.</summary>
    </member>
    <member name="T:System.Threading.EventWaitHandle">
      <summary>Représente un événement de synchronisation de threads.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />, en spécifiant si le handle d'attente est signalé initialement et s'il se réinitialise automatiquement ou manuellement.</summary>
      <param name="initialState">true pour définir l'état initial comme étant signalé ; false pour le définir comme étant non signalé.</param>
      <param name="mode">L'une des valeurs <see cref="T:System.Threading.EventResetMode" /> qui déterminent si l'événement se réinitialise automatiquement ou manuellement.</param>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />, en spécifiant si le handle d'attente est signalé initialement s'il a été créé à la suite de cet appel, s'il se réinitialise automatiquement ou manuellement, ainsi que le nom d'un événement de synchronisation du système.</summary>
      <param name="initialState">true pour définir l'état initial comme signalé si l'événement nommé est créé en conséquence de cet appel ; false pour le définir comme non signalé.</param>
      <param name="mode">L'une des valeurs <see cref="T:System.Threading.EventResetMode" /> qui déterminent si l'événement se réinitialise automatiquement ou manuellement.</param>
      <param name="name">Nom d'un événement de synchronisation à l'échelle du système.</param>
      <exception cref="T:System.IO.IOException">Une erreur Win32 s'est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException">L'événement nommé existe et possède la sécurité du contrôle d'accès, mais l'utilisateur ne possède pas <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'événement nommé ne peut pas être créé, peut-être parce qu'un handle d'attente d'un type différent possède le même nom.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> dépasse 260 caractères.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.EventWaitHandle" />, en spécifiant si le handle d'attente est signalé initialement s'il a été créé à la suite de cet appel, s'il se réinitialise automatiquement ou manuellement, ainsi que le nom d'un événement de synchronisation du système et une variable booléenne dont la valeur après l'appel indique si l'événement système nommé a été créé.</summary>
      <param name="initialState">true pour définir l'état initial comme signalé si l'événement nommé est créé en conséquence de cet appel ; false pour le définir comme non signalé.</param>
      <param name="mode">L'une des valeurs <see cref="T:System.Threading.EventResetMode" /> qui déterminent si l'événement se réinitialise automatiquement ou manuellement.</param>
      <param name="name">Nom d'un événement de synchronisation à l'échelle du système.</param>
      <param name="createdNew">Cette méthode retourne true si un événement local a été créé (en d'autres termes, si <paramref name="name" /> est null ou une chaîne vide) ou si l'événement système nommé spécifié a été créé ; false si l'événement système nommé spécifié existait déjà.Ce paramètre est passé sans être initialisé.</param>
      <exception cref="T:System.IO.IOException">Une erreur Win32 s'est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException">L'événement nommé existe et possède la sécurité du contrôle d'accès, mais l'utilisateur ne possède pas <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'événement nommé ne peut pas être créé, peut-être parce qu'un handle d'attente d'un type différent possède le même nom.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> dépasse 260 caractères.</exception>
    </member>
    <member name="M:System.Threading.EventWaitHandle.OpenExisting(System.String)">
      <summary>Ouvre l'événement de synchronisation nommé spécifié s'il existe déjà.</summary>
      <returns>Objet qui représente l'événement système nommé.</returns>
      <param name="name">Nom de l'événement de synchronisation système à ouvrir.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> est une chaîne vide. ou<paramref name="name" /> dépasse 260 caractères.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur null.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">L'événement de système nommé n'existe pas.</exception>
      <exception cref="T:System.IO.IOException">Une erreur Win32 s'est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException">L'événement nommé existe, mais l'utilisateur ne possède pas l'accès de sécurité requis pour l'utiliser.</exception>
      <filterpriority>1</filterpriority>
      <PermissionSet>
        <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="UnmanagedCode" />
      </PermissionSet>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Reset">
      <summary>Définit l'état de l'événement comme étant non signalé, entraînant le blocage des threads.</summary>
      <returns>true si l'opération aboutit ; sinon, false.</returns>
      <exception cref="T:System.ObjectDisposedException">La méthode <see cref="M:System.Threading.EventWaitHandle.Close" /> a été précédemment appelée sur ce <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.EventWaitHandle.Set">
      <summary>Définit l'état de l'événement comme étant signalé, ce qui permet à un ou plusieurs threads en attente de continuer.</summary>
      <returns>true si l'opération aboutit ; sinon, false.</returns>
      <exception cref="T:System.ObjectDisposedException">La méthode <see cref="M:System.Threading.EventWaitHandle.Close" /> a été précédemment appelée sur ce <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)">
      <summary>Ouvre l'événement de synchronisation nommé spécifié, s'il existe déjà, et retourne une valeur indiquant si l'opération a réussi.</summary>
      <returns>true si l'événement de synchronisation nommé a été ouvert ; sinon, false.</returns>
      <param name="name">Nom de l'événement de synchronisation système à ouvrir.</param>
      <param name="result">Lorsque cette méthode est retournée, contient un objet <see cref="T:System.Threading.EventWaitHandle" /> qui représente l'événement de synchronisation nommé si l'appel a réussi, ou null si l'appel a échoué.Ce paramètre est traité comme non initialisé.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> est une chaîne vide.ou<paramref name="name" /> dépasse 260 caractères.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur null.</exception>
      <exception cref="T:System.IO.IOException">Une erreur Win32 s'est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException">L'événement nommé existe, mais l'utilisateur n'a pas l'accès de sécurité voulu.</exception>
    </member>
    <member name="T:System.Threading.ExecutionContext">
      <summary>Gère le contexte d'exécution du thread actuel.Cette classe ne peut pas être héritée.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.ExecutionContext.Capture">
      <summary>Capture le contexte d'exécution du thread actuel.</summary>
      <returns>Objet <see cref="T:System.Threading.ExecutionContext" /> capturant le contexte d'exécution du thread actuel.</returns>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)">
      <summary>Exécute une méthode dans un contexte d'exécution spécifié sur le thread actuel.</summary>
      <param name="executionContext">
        <see cref="T:System.Threading.ExecutionContext" /> à définir.</param>
      <param name="callback">Délégué <see cref="T:System.Threading.ContextCallback" /> représentant la méthode à exécuter dans le contexte d'exécution fourni.</param>
      <param name="state">Objet à passer à la méthode de rappel.</param>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="executionContext" /> a la valeur null.ouLe <paramref name="executionContext" /> n'a pas été acquis à l'aide d'une opération de capture. ouLe <paramref name="executionContext" /> a déjà été utilisé comme argument pour un appel <see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)" />.</exception>
      <filterpriority>1</filterpriority>
      <PermissionSet>
        <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="Infrastructure" />
      </PermissionSet>
    </member>
    <member name="T:System.Threading.Interlocked">
      <summary>Fournit des opérations atomiques pour des variables partagées par plusieurs threads. </summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)">
      <summary>Ajoute deux entiers 32 bits et remplace le premier entier par la somme, sous la forme d'une opération atomique.</summary>
      <returns>La nouvelle valeur stockée à <paramref name="location1" />.</returns>
      <param name="location1">Variable qui contient la première valeur à ajouter.La somme des deux valeurs est stockée dans <paramref name="location1" />.</param>
      <param name="value">Valeur à ajouter à l'entier à <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">The address of <paramref name="location1" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)">
      <summary>Ajoute deux entiers 64 bits et remplace le premier entier par la somme, sous la forme d'une opération atomique.</summary>
      <returns>La nouvelle valeur stockée à <paramref name="location1" />.</returns>
      <param name="location1">Variable qui contient la première valeur à ajouter.La somme des deux valeurs est stockée dans <paramref name="location1" />.</param>
      <param name="value">Valeur à ajouter à l'entier à <paramref name="location1" />.</param>
      <exception cref="T:System.NullReferenceException">The address of <paramref name="location1" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)">
      <summary>Compare deux nombres à virgule flottante double précision et remplace le premier en cas d'égalité.</summary>
      <returns>Valeur d'origine dans <paramref name="location1" />.</returns>
      <param name="location1">Destination, dont la valeur est comparée à <paramref name="comparand" /> et qui peut être remplacée. </param>
      <param name="value">Valeur qui remplace la valeur de destination si la comparaison conclut à une égalité. </param>
      <param name="comparand">Valeur comparée à celle de <paramref name="location1" />. </param>
      <exception cref="T:System.NullReferenceException">The address of <paramref name="location1" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)">
      <summary>Compare deux entiers signés de 32 bits et remplace la première valeur en cas d'égalité.</summary>
      <returns>Valeur d'origine dans <paramref name="location1" />.</returns>
      <param name="location1">Destination, dont la valeur est comparée à <paramref name="comparand" /> et qui peut être remplacée. </param>
      <param name="value">Valeur qui remplace la valeur de destination si la comparaison conclut à une égalité. </param>
      <param name="comparand">Valeur comparée à celle de <paramref name="location1" />. </param>
      <exception cref="T:System.NullReferenceException">The address of <paramref name="location1" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)">
      <summary>Compare deux entiers signés de 64 bits et remplace la première valeur en cas d'égalité.</summary>
      <returns>Valeur d'origine dans <paramref name="location1" />.</returns>
      <param name="location1">Destination, dont la valeur est comparée à <paramref name="comparand" /> et qui peut être remplacée. </param>
      <param name="value">Valeur qui remplace la valeur de destination si la comparaison conclut à une égalité. </param>
      <param name="comparand">Valeur comparée à celle de <paramref name="location1" />. </param>
      <exception cref="T:System.NullReferenceException">The address of <paramref name="location1" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)">
      <summary>Compare deux handles ou pointeurs spécifiques à la plateforme et remplace le premier en cas d'égalité.</summary>
      <returns>Valeur d'origine dans <paramref name="location1" />.</returns>
      <param name="location1">
        <see cref="T:System.IntPtr" /> de destination, dont la valeur est comparée à celle de <paramref name="comparand" /> et qui peut être remplacée par <paramref name="value" />. </param>
      <param name="value">
        <see cref="T:System.IntPtr" /> qui remplace la valeur de destination si la comparaison conclut à une égalité. </param>
      <param name="comparand">
        <see cref="T:System.IntPtr" /> comparée à la valeur de <paramref name="location1" />. </param>
      <exception cref="T:System.NullReferenceException">The address of <paramref name="location1" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)">
      <summary>Compare deux objets et remplace le premier en cas d'égalité des références.</summary>
      <returns>Valeur d'origine dans <paramref name="location1" />.</returns>
      <param name="location1">Objet de destination comparé à <paramref name="comparand" /> et qui peut être remplacé. </param>
      <param name="value">Objet qui remplace l'objet de destination si la comparaison conclut à une égalité. </param>
      <param name="comparand">Objet qui est comparé à l'objet se trouvant à <paramref name="location1" />. </param>
      <exception cref="T:System.ArgumentNullException">The address of <paramref name="location1" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)">
      <summary>Compare deux nombres à virgule flottante simple précision et remplace le premier en cas d'égalité.</summary>
      <returns>Valeur d'origine dans <paramref name="location1" />.</returns>
      <param name="location1">Destination, dont la valeur est comparée à <paramref name="comparand" /> et qui peut être remplacée. </param>
      <param name="value">Valeur qui remplace la valeur de destination si la comparaison conclut à une égalité. </param>
      <param name="comparand">Valeur comparée à celle de <paramref name="location1" />. </param>
      <exception cref="T:System.NullReferenceException">The address of <paramref name="location1" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)">
      <summary>Compare deux instances du type référence spécifié <paramref name="T" /> et remplace la première en cas d'égalité.</summary>
      <returns>Valeur d'origine dans <paramref name="location1" />.</returns>
      <param name="location1">Destination, dont la valeur est comparée avec <paramref name="comparand" /> et qui peut être remplacée.C'est un paramètre référence (ref en C#, ByRef en Visual Basic).</param>
      <param name="value">Valeur qui remplace la valeur de destination si la comparaison conclut à une égalité. </param>
      <param name="comparand">Valeur comparée à celle de <paramref name="location1" />. </param>
      <typeparam name="T">Type à utiliser pour <paramref name="location1" />, <paramref name="value" /> et <paramref name="comparand" />.Ce type doit être un type référence.</typeparam>
      <exception cref="T:System.NullReferenceException">The address of <paramref name="location1" /> is a null pointer. </exception>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int32@)">
      <summary>Décrémente une variable spécifiée et stocke le résultat, sous la forme d'une opération atomique.</summary>
      <returns>Valeur décrémentée.</returns>
      <param name="location">Variable dont la valeur doit être décrémentée. </param>
      <exception cref="T:System.ArgumentNullException">The address of <paramref name="location" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Decrement(System.Int64@)">
      <summary>Décrémente la variable spécifiée et stocke le résultat sous la forme d'une opération atomique.</summary>
      <returns>Valeur décrémentée.</returns>
      <param name="location">Variable dont la valeur doit être décrémentée. </param>
      <exception cref="T:System.ArgumentNullException">The address of <paramref name="location" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)">
      <summary>Affecte une valeur spécifiée à un nombre à virgule flottante double précision, puis retourne la valeur d'origine, sous la forme d'une opération atomique.</summary>
      <returns>Valeur d'origine de <paramref name="location1" />.</returns>
      <param name="location1">Variable à laquelle affecter la valeur spécifiée. </param>
      <param name="value">Valeur affectée au paramètre <paramref name="location1" />. </param>
      <exception cref="T:System.NullReferenceException">The address of <paramref name="location1" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)">
      <summary>Affecte un entier signé 32 bits à une valeur spécifiée, puis retourne la valeur d'origine, sous la forme d'une opération atomique.</summary>
      <returns>Valeur d'origine de <paramref name="location1" />.</returns>
      <param name="location1">Variable à laquelle affecter la valeur spécifiée. </param>
      <param name="value">Valeur affectée au paramètre <paramref name="location1" />. </param>
      <exception cref="T:System.ArgumentNullException">The address of <paramref name="location1" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)">
      <summary>Affecte une valeur spécifiée à un entier signé 64 bits, puis retourne la valeur d'origine, sous la forme d'une opération atomique.</summary>
      <returns>Valeur d'origine de <paramref name="location1" />.</returns>
      <param name="location1">Variable à laquelle affecter la valeur spécifiée. </param>
      <param name="value">Valeur affectée au paramètre <paramref name="location1" />. </param>
      <exception cref="T:System.NullReferenceException">The address of <paramref name="location1" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)">
      <summary>Affecte une valeur spécifiée à un handle ou un pointeur spécifique à la plateforme, puis retourne la valeur d'origine, sous la forme d'une opération atomique.</summary>
      <returns>Valeur d'origine de <paramref name="location1" />.</returns>
      <param name="location1">Variable à laquelle affecter la valeur spécifiée. </param>
      <param name="value">Valeur affectée au paramètre <paramref name="location1" />. </param>
      <exception cref="T:System.NullReferenceException">The address of <paramref name="location1" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)">
      <summary>Affecte une valeur spécifiée à un objet, puis retourne une référence à l'objet d'origine sous la forme d'une opération atomique.</summary>
      <returns>Valeur d'origine de <paramref name="location1" />.</returns>
      <param name="location1">Variable à laquelle affecter la valeur spécifiée. </param>
      <param name="value">Valeur affectée au paramètre <paramref name="location1" />. </param>
      <exception cref="T:System.ArgumentNullException">The address of <paramref name="location1" /> is a null pointer. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)">
      <summary>Affecte une valeur spécifiée à un nombre à virgule flottante simple précision, puis retourne la valeur d'origine, sous la forme d'une opération atomique.</summary>
      <returns>Valeur d'origine de <paramref name="location1" />.</returns>
      <param name="location1">Variable à laquelle affecter la valeur spécifiée. </param>
      <param name="value">ValeurINDX( 	             (   H                            v     p \     u     //gSgSg//g                        M o n o A n d r o i d 1 0     x     h X     u     e`gFEgFEge`g                        M o n o T o u c h 1 0 z     ` L     u     nBg%kg%kgnBg                        n e t 4 5     |     ` N     u     *gزiزi*g                        n e t 4 6 2   ~      |     u     +iȸi ȸi+i                        p o r t a b l e - n e t 4 5 + w i n 8 + w p 8 + w p a 8 1          ` J     u     diiidi                        w i n 8            ` J     u     @iii@i                        w p 8 0            ` L     u     i'i'ii                        w p a 8 1          p Z     u     iiii                        x a m a r i n i o s 1 0            p Z     u     iiii                        x a m a r i n m a c 2 0            p \     u     IiWiWiIi                        x a m a r i n t v o s 1 0          x b     u     iiii                        x a m a r i n w a t c h o s 1 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               INDX( 	             (                                  q     p ^     p     .g uG	g P      I               . s i g n a t u r e . p 7 s   r      v     p     	hg Ԣ4M	 g 0      $               d o t n e t _ l i b r a r y _ l i c e n s e . t x t   u     X H     p     giii                        l i b      X H     p     Acib(                        r e f s           p     ^g׏	׏	g `     Q             % S y s t e m . R u n t i m e . E x t e n s i o n s . 4 . 3 . 1 . n u p k g     t      l     p     *5g Ԣ4]׀	*5g       Q               T h i r d P a r t y N o t i c e s . t x t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    MZ                @                                       	!L!This program cannot be run in DOS mode.
$       PE  L r[\         " 0  4         S       `                                ]  @                           S  O    `  	           B   ?        R                                                               H           .text   3       4                    `.rsrc   	   `   
   6              @  @.reloc            @              @  B                S      H     P#    	       @    |R                                     r~  -(-  s  
  ~  *
*0 $     
(  o  

& ,o  
,**        ,!(  ,r  p(  
(  
*(  
**(  ,r  p  %%(  
*(	  
*(  ,r  p  %%%(  
*(
  
*(  ,!r  p  %%%%(  
*(  
*2r  p(  *2r9  p(  *2r  p(  *2r  p(  *2r	 p(  *2rG p(  *2ro p(  *2r p(  *2r p(  *2r p(  *2rU p(  *2r p(  *2r p(  *2r# p(  *2rU p(  *2r{ p(  *2r p(  *2r p(  *2r p(  *2r p(  *2r? p(  *2ri p(  *2r p(  *2r p(  *2r3 p(  *2rQ p(  *2rq p(  *2r p(  *2r p(  *2r? p(  *2rq p(  *2r p(  *2r p(  *2r p(  *2r/ p(  *2rU p(  *2r p(  *.  (  
*  BSJB         v4.0.30319     l      #~    	  #Strings    <    #US      #GUID        #Blob         W]	   3               -                        '   '                          @> >  # . 7      = g7      \ y $      P  x z  j	            ?     ?     3QP      m      p      '                -   !     3  .!     : 
 a!    3 n!    { {!      !    R !     !     !     !    	 !    t !    .	 !      !    ( !     
"     "     $"     1"      >"    K  K"    Z X"    	 e"    [ r"    a  "      "     "    > "      "     "    ` "     "    z "     "     #    ` #    , #    I (#    \	 5#     B#    "    P	   0                                       	 a ! a ! & 1  I a 1 M 1 ' 1  1 - 1 3 1 : ) B Y aI a a i aN y aT  aT  aT  aT  aT  aT  aT  aT  aT  aY  a^  ad  aY  a  a   '  . k 1. s :. { Y.  b.  m.  m.  m.  .  .  .  .  .  V.  \.  x +   aj     #  7       V        	  x  2	     ,          "   O   ^  	  _  e        B       d    ~      d  0  M  `	    &#       	   
 	                                    !   #   %   '   )   +   -   /   1   3    5  ! 7  " 9  # ;  $ =  % ?  & A  ' C  ( E  ) G  * I  + K  , M  - O $          n $             (B                (            T                  Qg	                  5          [                  ~		                            	         E         	             Progress`1 p1 p2 p3 <Module> get_Arg_PathIllegalUNC System.IO SR mscorlib get_Arg_Path2IsRooted get_Argument_PathFormatNotSupported get_Argument_PathUriFormatNotSupported get_Argument_FrameworkNameInvalid get_IO_FileNotFound get_ArgumentOutOfRange_LengthTooLarge RuntimeTypeHandle GetTypeFromHandle get_IO_SharingViolation_File get_IO_FileExists_Name get_IO_AlreadyExists_Name get_IO_FileNotFound_FileName get_IO_SharingViolation_NoFileName get_UnauthorizedAccess_IODenied_NoPathName get_IO_PathNotFound_NoPathName FrameworkName s_resourcesName get_ResourceType get_Argument_AddingDuplicate AssemblyMetadataAttribute UnverifiableCodeAttribute AttributeUsageAttribute NeutralResourcesLanguageAttribute DebuggableAttribute ComVisibleAttribute AssemblyTitleAttribute AssemblyFileVersionAttribute AssemblyInformationalVersionAttribute SecurityPermissionAttribute AssemblyDescriptionAttribute AssemblyDefaultAliasAttribute FlagsAttribute CompilationRelaxationsAttribute AssemblyProductAttribute AssemblyCopyrightAttribute CLSCompliantAttribute ParamArrayAttribute AssemblyCompanyAttribute RuntimeCompatibilityAttribute get_Argument_MinMaxValue get_ArgumentOutOfRange_GenericPositive get_ArgumentOutOfRange_MustBePositive get_ArgumentOutOfRange_FileLengthTooBig MidpointRounding System.Runtime.Versioning GetResourceString GetString defaultString get_IO_PathTooLong Stopwatch Math get_UnauthorizedAccess_IODenied_Path get_IO_PathNotFound_Path get_Arg_PathIllegal get_net_emptystringcall get_Arg_ArrayPlusOffTooSmall System.Runtime.Extensions.dll System Random get_UnknownError_Num get_ArgumentOutOfRange_NeedNonNegNum Join get_Argument_FrameworkNameInvalidVersion get_Argument_FrameworkNameMissingVersion SecurityAction System.Reflection MissingManifestResourceException StringComparison get_Arg_InvalidSearchPattern UriBuilder get_ResourceManager s_resourceManager StringComparer BitConverter .ctor System.Diagnostics System.Runtime.InteropServices System.Runtime.CompilerServices System.Resources FxResources.System.Runtime.Extensions.SR.resources DebuggingModes args Equals FxResources.System.Runtime.Extensions System.Security.Permissions get_Argument_InvalidPathChars AttributeTargets UsingResourceKeys Concat resourceFormat Object System.Net Environment get_Arg_PathGlobalRoot Convert get_Argument_FrameworkNameTooShort get_ArgumentOutOfRange_Index get_ArgumentOutOfRange_StartIndex resourceKey get_InvalidOperation_Cryptography WebUtility System.Security get_Argument_PathEmpty  ,    1A r g u m e n t _ A d d i n g D u p l i c a t e  IA r g u m e n t _ F r a m e w o r k N a m e M i s s i n g V e r s i o n  ;A r g u m e n t _ F r a m e w o r k N a m e I n v a l i d  IA r g u m e n t _ F r a m e w o r k N a m e I n v a l i d V e r s i o n  =A r g u m e n t _ F r a m e w o r k N a m e T o o S h o r t  'n e t _ e m p t y s t r i n g c a l l  1A r g _ A r r a y P l u s O f f T o o S m a l l  1A r g u m e n t O u t O f R a n g e _ I n d e x  EA r g u m e n t O u t O f R a n g e _ G e n e r i c P o s i t i v e  ;A r g u m e n t O u t O f R a n g e _ S t a r t I n d e x  CA r g u m e n t O u t O f R a n g e _ L e n g t h T o o L a r g e  AA r g u m e n t O u t O f R a n g e _ N e e d N o n N e g N u m  GA r g u m e n t O u t O f R a n g e _ F i l e L e n g t h T o o B i g  1A r g _ I n v a l i d S e a r c h P a t t e r n  %A r g _ P a t h G l o b a l R o o t  A r g _ P a t h I l l e g a l  %A r g _ P a t h I l l e g a l U N C  #A r g _ P a t h 2 I s R o o t e d  3A r g u m e n t _ I n v a l i d P a t h C h a r s  %A r g u m e n t _ P a t h E m p t y  )A r g u m e n t _ M i n M a x V a l u e  ?A r g u m e n t _ P a t h F o r m a t N o t S u p p o r t e d  EA r g u m e n t _ P a t h U r i F o r m a t N o t S u p p o r t e d  CA r g u m e n t O u t O f R a n g e _ M u s t B e P o s i t i v e  I O _ P a t h T o o L o n g  I O _ F i l e N o t F o u n d  MU n a u t h o r i z e d A c c e s s _ I O D e n i e d _ N o P a t h N a m e  AU n a u t h o r i z e d A c c e s s _ I O D e n i e d _ P a t h  =I O _ S h a r i n g V i o l a t i o n _ N o F i l e N a m e  1I O _ F i l e N o t F o u n d _ F i l e N a m e  5I O _ P a t h N o t F o u n d _ N o P a t h N a m e  )I O _ P a t h N o t F o u n d _ P a t h  +I O _ A l r e a d y E x i s t s _ N a m e  1I O _ S h a r i n g V i o l a t i o n _ F i l e  %I O _ F i l e E x i s t s _ N a m e  ;I n v a l i d O p e r a t i o n _ C r y p t o g r a p h y  !U n k n o w n E r r o r _ N u m   OoOzH  	           )  9    m $          $  RSA1     WĮ.j쏇vlLsi <see cref="T:System.Threading.ManualResetEventSlim" /> a été défini ; sinon, false.</returns>
      <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> was canceled.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
      <exception cref="T:System.InvalidOperationException">The maximum number of waiters has been exceeded.</exception>
      <exception cref="T:System.ObjectDisposedException">The object has already been disposed or the <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has been disposed.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.Threading.CancellationToken)">
      <summary>Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.ManualResetEventSlim" /> actuel reçoive un signal, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <exception cref="T:System.InvalidOperationException">The maximum number of waiters has been exceeded.</exception>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> was canceled.</exception>
      <exception cref="T:System.ObjectDisposedException">The object has already been disposed or the <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has been disposed.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan)">
      <summary>Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.ManualResetEventSlim" /> actuel soit défini, à l'aide d'un <see cref="T:System.TimeSpan" /> pour mesurer l'intervalle de temps.</summary>
      <returns>true si <see cref="T:System.Threading.ManualResetEventSlim" /> a été défini ; sinon, false.</returns>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millisecondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 milliseconde pour un délai d'attente infini.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out. -or-The number of milliseconds in <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />. </exception>
      <exception cref="T:System.InvalidOperationException">The maximum number of waiters has been exceeded.</exception>
      <exception cref="T:System.ObjectDisposedException">The object has already been disposed.</exception>
    </member>
    <member name="M:System.Threading.ManualResetEventSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)">
      <summary>Bloque le thread actuel jusqu'à ce que le <see cref="T:System.Threading.ManualResetEventSlim" /> actuel soit défini, à l'aide d'un <see cref="T:System.TimeSpan" /> pour mesurer l'intervalle de temps, tout en observant un <see cref="T:System.Threading.CancellationToken" />.</summary>
      <returns>true si <see cref="T:System.Threading.ManualResetEventSlim" /> a été défini ; sinon, false.</returns>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> qui représente le nombre de millisecondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 milliseconde pour un délai d'attente infini.</param>
      <param name="cancellationToken">
        <see cref="T:System.Threading.CancellationToken" /> à observer.</param>
      <exception cref="T:System.OperationCanceledException">
        <paramref name="cancellationToken" /> was canceled.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out. -or-The number of milliseconds in <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />. </exception>
      <exception cref="T:System.InvalidOperationException">The maximum number of waiters has been exceeded. </exception>
      <exception cref="T:System.ObjectDisposedException">The object has already been disposed or the <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has been disposed.</exception>
    </member>
    <member name="P:System.Threading.ManualResetEventSlim.WaitHandle">
      <summary>Obtient l'objet <see cref="T:System.Threading.WaitHandle" /> sous-jacent pour ce <see cref="T:System.Threading.ManualResetEventSlim" />.</summary>
      <returns>Objet d'événement <see cref="T:System.Threading.WaitHandle" /> sous-jacent pour ce <see cref="T:System.Threading.ManualResetEventSlim" />.</returns>
    </member>
    <member name="T:System.Threading.Monitor">
      <summary>Fournit un mécanisme qui synchronise l'accès aux objets.</summary>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object)">
      <summary>Acquiert un verrou exclusif sur l'objet spécifié.</summary>
      <param name="obj">Objet sur lequel acquérir le verrou du moniteur. </param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur null. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)">
      <summary>Acquiert un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</summary>
      <param name="obj">Objet sur lequel attendre. </param>
      <param name="lockTaken">Résultat de la tentative d'acquisition du verrou, passé par la référence.L'entrée doit avoir la valeur false.La sortie a la valeur true si un verrou est acquis ; sinon, elle a la valeur false.La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.Remarque   Si aucune exception ne se produit, la sortie de cette méthode est toujours true.</param>
      <exception cref="T:System.ArgumentException">L'entrée du paramètre <paramref name="lockTaken" /> a la valeur true.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur null. </exception>
    </member>
    <member name="M:System.Threading.Monitor.Exit(System.Object)">
      <summary>Libère un verrou exclusif sur l'objet spécifié.</summary>
      <param name="obj">Objet sur lequel libérer le verrou. </param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur null. </exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Le thread en cours ne possède pas le verrou pour l'objet spécifié. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.IsEntered(System.Object)">
      <summary>Détermine si le thread actuel détient le verrou sur l'objet spécifié. </summary>
      <returns>true si le thread actuel détient le verrou sur <paramref name="obj" /> ; sinon, false.</returns>
      <param name="obj">Objet à tester. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="obj" /> a la valeur null. </exception>
    </member>
    <member name="M:System.Threading.Monitor.Pulse(System.Object)">
      <summary>Avertit un thread situé dans la file d'attente en suspens d'un changement d'état de l'objet verrouillé.</summary>
      <param name="obj">Objet attendu par un thread. </param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur null. </exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Le thread appelant ne possède pas le verrou pour l'objet spécifié. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.PulseAll(System.Object)">
      <summary>Avertit tous les threads en attente d'un changement d'état de l'objet.</summary>
      <param name="obj">Objet qui envoie l'impulsion. </param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur null. </exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Le thread appelant ne possède pas le verrou pour l'objet spécifié. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object)">
      <summary>Essaie d'acquérir un verrou exclusif sur l'objet spécifié.</summary>
      <returns>true si le thread actuel acquiert le verrou ; sinon, false.</returns>
      <param name="obj">Objet sur lequel acquérir le verrou. </param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur null. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)">
      <summary>Tente d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</summary>
      <param name="obj">Objet sur lequel acquérir le verrou. </param>
      <param name="lockTaken">Résultat de la tentative d'acquisition du verrou, passé par la référence.L'entrée doit avoir la valeur false.La sortie a la valeur true si un verrou est acquis ; sinon, elle a la valeur false.La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</param>
      <exception cref="T:System.ArgumentException">L'entrée du paramètre <paramref name="lockTaken" /> a la valeur true.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur null. </exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)">
      <summary>Tentatives d'acquisition d'un verrou exclusif sur l'objet spécifié au cours du nombre spécifié de millisecondes.</summary>
      <returns>true si le thread actuel acquiert le verrou ; sinon, false.</returns>
      <param name="obj">Objet sur lequel acquérir le verrou. </param>
      <param name="millisecondsTimeout">Délai d'attente du verrou en millisecondes. </param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur null. </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> est négatif et différent de <see cref="F:System.Threading.Timeout.Infinite" />. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)">
      <summary>Tente, pendant le nombre spécifié de millisecondes, d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</summary>
      <param name="obj">Objet sur lequel acquérir le verrou. </param>
      <param name="millisecondsTimeout">Délai d'attente du verrou en millisecondes. </param>
      <param name="lockTaken">Résultat de la tentative d'acquisition du verrou, passé par la référence.L'entrée doit avoir la valeur false.La sortie a la valeur true si un verrou est acquis ; sinon, elle a la valeur false.La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</param>
      <exception cref="T:System.ArgumentException">L'entrée du paramètre <paramref name="lockTaken" /> a la valeur true.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur null. </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> est négatif et différent de <see cref="F:System.Threading.Timeout.Infinite" />. </exception>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)">
      <summary>Tentatives d'acquisition d'un verrou exclusif sur l'objet spécifié au cours de la période spécifiée.</summary>
      <returns>true si le thread actuel acquiert le verrou ; sinon, false.</returns>
      <param name="obj">Objet sur lequel acquérir le verrou. </param>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> représentant le délai d'attente du verrou.Une valeur de –1 milliseconde spécifie une attente infinie.</param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur null. </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La valeur en millisecondes de <paramref name="timeout" /> est négative et différente de <see cref="F:System.Threading.Timeout.Infinite" /> (–1 milliseconde), ou elle est supérieure à <see cref="F:System.Int32.MaxValue" />. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)">
      <summary>Tente, pendant le délai spécifié, d'acquérir un verrou exclusif sur l'objet spécifié et définit de manière atomique une valeur qui indique si le verrou a été pris.</summary>
      <param name="obj">Objet sur lequel acquérir le verrou. </param>
      <param name="timeout">Délai d'attente du verrou.Une valeur de –1 milliseconde spécifie une attente infinie.</param>
      <param name="lockTaken">Résultat de la tentative d'acquisition du verrou, passé par la référence.L'entrée doit avoir la valeur false.La sortie a la valeur true si un verrou est acquis ; sinon, elle a la valeur false.La sortie est définie même si une exception se produit lors de la tentative d'acquisition du verrou.</param>
      <exception cref="T:System.ArgumentException">L'entrée du paramètre <paramref name="lockTaken" /> a la valeur true.</exception>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur null. </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La valeur en millisecondes de <paramref name="timeout" /> est négative et différente de <see cref="F:System.Threading.Timeout.Infinite" /> (–1 milliseconde), ou elle est supérieure à <see cref="F:System.Int32.MaxValue" />. </exception>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object)">
      <summary>Libère le verrou d'un objet et bloque le thread actuel jusqu'à ce qu'il acquière à nouveau le verrou.</summary>
      <returns>true si l'appel est retourné car l'appelant a de nouveau acquis le verrou pour l'objet spécifié.Cette méthode ne retourne rien si le verrou n'est pas acquis à nouveau.</returns>
      <param name="obj">Objet sur lequel attendre. </param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur null. </exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Le thread appelant ne possède pas le verrou pour l'objet spécifié. </exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Le thread qui appelle Wait quitte ensuite l'état d'attente.Cela se produit lorsqu'un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.Int32)">
      <summary>Libère le verrou d'un objet et bloque le thread actuel jusqu'à ce qu'il acquière à nouveau le verrou.Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle.</summary>
      <returns>true si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; false si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié.La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</returns>
      <param name="obj">Objet sur lequel attendre. </param>
      <param name="millisecondsTimeout">Nombre de millisecondes à attendre avant que le thread intègre la file d'attente opérationnelle. </param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur null. </exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Le thread appelant ne possède pas le verrou pour l'objet spécifié. </exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Le thread qui appelle Wait quitte ensuite l'état d'attente.Cela se produit lorsqu'un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La valeur du paramètre <paramref name="millisecondsTimeout" /> est négative et différente de <see cref="F:System.Threading.Timeout.Infinite" />. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)">
      <summary>Libère le verrou d'un objet et bloque le thread actuel jusqu'à ce qu'il acquière à nouveau le verrou.Si le délai d'attente spécifié est écoulé, le thread intègre la file d'attente opérationnelle.</summary>
      <returns>true si le verrou a fait l'objet d'une nouvelle acquisition avant l'expiration du délai spécifié ; false si le verrou a fait l'objet d'une nouvelle acquisition après l'expiration du délai spécifié.La méthode ne retourne pas de valeur tant que le verrou n'est pas acquis à nouveau.</returns>
      <param name="obj">Objet sur lequel attendre. </param>
      <param name="timeout">
        <see cref="T:System.TimeSpan" /> qui représente le temps à attendre avant que le thread n'intègre la file d'attente opérationnelle. </param>
      <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="obj" /> a la valeur null. </exception>
      <exception cref="T:System.Threading.SynchronizationLockException">Le thread appelant ne possède pas le verrou pour l'objet spécifié. </exception>
      <exception cref="T:System.Threading.ThreadInterruptedException">Le thread qui appelle Wait quitte ensuite l'état d'attente.Cela se produit lorsqu'un autre thread appelle la méthode <see cref="M:System.Threading.Thread.Interrupt" /> de ce thread.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">La valeur en millisecondes du paramètre <paramref name="timeout" /> est négative et ne représente pas <see cref="F:System.Threading.Timeout.Infinite" /> (–1 milliseconde) ou est supérieure à <see cref="F:System.Int32.MaxValue" />. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="T:System.Threading.Mutex">
      <summary>Primitive de synchronisation qui peut également être utilisée pour la synchronisation entre processus. </summary>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Mutex.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Mutex" /> avec des propriétés par défaut.</summary>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Mutex" /> avec une valeur booléenne qui indique si le thread appelant doit avoir la propriété initiale du mutex.</summary>
      <param name="initiallyOwned">true pour accorder au thread appelant la propriété initiale du mutex ; sinon, false. </param>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Mutex" /> avec une valeur booléenne qui indique si le thread appelant doit avoir la propriété initiale du mutex, et une chaîne représentant le nom du mutex.</summary>
      <param name="initiallyOwned">true pour donner au thread appelant la propriété initiale du mutex système nommé si celui-ci est créé en réponse à cet appel ; sinon, false. </param>
      <param name="name">Nom du <see cref="T:System.Threading.Mutex" />.Si cette valeur est null, <see cref="T:System.Threading.Mutex" /> est sans nom.</param>
      <exception cref="T:System.UnauthorizedAccessException">Le mutex nommé existe et possède la sécurité du contrôle d'accès, mais l'utilisateur ne possède pas <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException">Une erreur Win32 s'est produite.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Le mutex nommé ne peut pas être créé, peut-être parce qu'un handle d'attente d'un type différent possède le même nom.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> est plus de 260 caractères.</exception>
    </member>
    <member name="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.Mutex" /> avec une valeur booléenne qui indique si le thread appelant doit avoir la propriété initiale du mutex, une chaîne qui représente le nom du mutex et une valeur booléenne qui, quand la méthode retourne son résultat, indique si la propriété initiale du mutex a été accordée au thread appelant.</summary>
      <param name="initiallyOwned">true pour donner au thread appelant la propriété initiale du mutex système nommé si celui-ci est créé en réponse à cet appel ; sinon, false. </param>
      <param name="name">Nom du <see cref="T:System.Threading.Mutex" />.Si cette valeur est null, <see cref="T:System.Threading.Mutex" /> est sans nom.</param>
      <param name="createdNew">Cette méthode retourne une valeur booléenne qui est true si un mutex local a été créé (en d'autres termes, si <paramref name="name" /> est null ou une chaîne vide) ou si le mutex système nommé spécifié a été créé ; false si le mutex système nommé spécifié existait déjà.Ce paramètre est passé sans être initialisé.</param>
      <exception cref="T:System.UnauthorizedAccessException">Le mutex nommé existe et possède la sécurité du contrôle d'accès, mais l'utilisateur ne possède pas <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</exception>
      <exception cref="T:System.IO.IOException">Une erreur Win32 s'est produite.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Le mutex nommé ne peut pas être créé, peut-être parce qu'un handle d'attente d'un type différent possède le même nom.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> est plus de 260 caractères.</exception>
    </member>
    <member name="M:System.Threading.Mutex.OpenExisting(System.String)">
      <summary>Ouvre le mutex nommé spécifié, s'il existe déjà.</summary>
      <returns>Objet qui représente le mutex système nommé.</returns>
      <param name="name">Nom du mutex système à ouvrir.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> est une chaîne vide.ou<paramref name="name" /> est plus de 260 caractères.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur null.</exception>
      <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">Le mutex nommé n'existe pas.</exception>
      <exception cref="T:System.IO.IOException">Une erreur Win32 s'est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Le mutex nommé existe, mais l'utilisateur ne possède pas l'accès de sécurité requis pour l'utiliser.</exception>
      <filterpriority>1</filterpriority>
      <PermissionSet>
        <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="UnmanagedCode" />
      </PermissionSet>
    </member>
    <member name="M:System.Threading.Mutex.ReleaseMutex">
      <summary>Libère l'objet <see cref="T:System.Threading.Mutex" /> une seule fois.</summary>
      <exception cref="T:System.ApplicationException">Le thread appelant ne possède pas le mutex. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)">
      <summary>Ouvre le mutex nommé spécifié, s'il existe déjà, et retourne une valeur indiquant si l'opération a réussi.</summary>
      <returns>true si le mutex nommé a été ouvert ; sinon, false.</returns>
      <param name="name">Nom du mutex système à ouvrir.</param>
      <param name="result">Quand cette méthode est retournée, contient un objet <see cref="T:System.Threading.Mutex" /> qui représente la structure mutex nommée si l'appel a réussi, ou null si l'appel a échoué.Ce paramètre est traité comme étant non initialisé.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="name" /> est une chaîne vide.ou<paramref name="name" /> est plus de 260 caractères.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="name" /> a la valeur null.</exception>
      <exception cref="T:System.IO.IOException">Une erreur Win32 s'est produite.</exception>
      <exception cref="T:System.UnauthorizedAccessException">Le mutex nommé existe, mais l'utilisateur ne possède pas l'accès de sécurité requis pour l'utiliser.</exception>
    </member>
    <member name="T:System.Threading.ReaderWriterLockSlim">
      <summary>Représente un verrou utilisé pour gérer l'accès à une ressource, en autorisant plusieurs threads pour la lecture ou un accès exclusif en écriture.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ReaderWriterLockSlim" /> avec des valeurs de propriété par défaut.</summary>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Threading.ReaderWriterLockSlim" />, en spécifiant la stratégie de récurrence du verrou.</summary>
      <param name="recursionPolicy">Une des valeurs d'énumération qui spécifie la stratégie de récurrence du verrou. </param>
    </member>
    <member name="P:System.Threading.ReaderWriterLockSlim.CurrentReadCount">
      <summary>Obtient le nombre total de threads uniques qui ont entré le verrou en mode lecture.</summary>
      <returns>Nombre de threads uniques qui ont entré le verrou en mode lecture.</returns>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.Dispose">
      <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Threading.ReaderWriterLockSlim" />.</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">
        <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero. -or-<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero. -or-<see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero. </exception>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterReadLock">
      <summary>Essaie d'entrer le verrou en mode lecture.</summary>
      <exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered read mode. -or-The current thread may not acquire the read lock when it already holds the write lock. -or-The recursion number would exceed the capacity of the counter.This limit is so large that applications should never encounter it.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed. </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock">
      <summary>Essaie d'entrer le verrou en mode pouvant être mis à niveau.</summary>
      <exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode. -or-The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock. -or-The recursion number would exceed the capacity of the counter.The limit is so large that applications should never encounter it.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed. </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.EnterWriteLock">
      <summary>Essaie d'entrer le verrou en mode écriture.</summary>
      <exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode. -or-The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock. -or-The recursion number would exceed the capacity of the counter.The limit is so large that applications should never encounter it.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed. </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitReadLock">
      <summary>Réduit le nombre de récurrences pour le mode lecture, et quitte le mode lecture si le nombre résultant est 0 (zéro).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">The current thread has not entered the lock in read mode. </exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock">
      <summary>Réduit le nombre de récurrences pour le mode pouvant être mis à niveau, et quitte le mode pouvant être mis à niveau si le nombre résultant est 0 (zéro).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">The current thread has not entered the lock in upgradeable mode.</exception>
    </member>
    <member name="M:System.Threading.ReaderWriterLockSlim.ExitWriteLock">
      <summary>Réduit le nombre de récurrences pour le mode écriture, et quitte le mode écriture si le nombre résultant est 0 (zéro).</summary>
      <exception cref="T:System.Threading.SynchronizationLockException">The current thread has not entered the lock in write mode.</exception>
    </member>  =>?@ABCDEFGHIJK LMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ gne suivante du flux d'entrée, ou null si la fin du flux d'entrée est atteinte.</returns>
      <exception cref="T:System.OutOfMemoryException">La mémoire disponible est insuffisante pour allouer une mémoire tampon pour la chaîne retournée. </exception>
      <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.IO.StreamReader.ReadLineAsync">
      <summary>Lit une ligne de caractères de manière asynchrone dans le flux actuel et retourne les données sous forme de chaîne.</summary>
      <returns>Tâche qui représente l'opération de lecture asynchrone.La valeur du paramètre <paramref name="TResult" /> contient la ligne suivante du flux, ou a la valeur null si tous les caractères ont été lus.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Le nombre de caractères contenus dans la ligne suivante est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Le flux a été supprimé.</exception>
      <exception cref="T:System.InvalidOperationException">Lecteur est en cours d'utilisation par une opération de lecture précédente. </exception>
    </member>
    <member name="M:System.IO.StreamReader.ReadToEnd">
      <summary>Lit tous les caractères entre la position actuelle et la fin du flux.</summary>
      <returns>Le reste du flux sous forme de chaîne, de la position actuelle jusqu'à la fin.Si la position actuelle est à la fin du flux, retourne une chaîne vide ("").</returns>
      <exception cref="T:System.OutOfMemoryException">La mémoire disponible est insuffisante pour allouer une mémoire tampon pour la chaîne retournée. </exception>
      <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.IO.StreamReader.ReadToEndAsync">
      <summary>Lit tous les caractères entre la position actuelle et la fin du flux de manière asynchrone, puis les retourne sous la forme d'une chaîne.</summary>
      <returns>Tâche qui représente l'opération de lecture asynchrone.La valeur du paramètre <paramref name="TResult" /> contient une chaîne composée des caractères allant de la position actuelle à la fin du flux.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Le nombre de caractères est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
      <exception cref="T:System.ObjectDisposedException">Le flux a été supprimé.</exception>
      <exception cref="T:System.InvalidOperationException">Lecteur est en cours d'utilisation par une opération de lecture précédente. </exception>
    </member>
    <member name="T:System.IO.StreamWriter">
      <summary>Implémente <see cref="T:System.IO.TextWriter" /> pour écrire les caractères dans un flux selon un encodage particulier.Pour parcourir le code source de .NET Framework pour ce type, consultez la Source de référence.</summary>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.IO.StreamWriter.#ctor(System.IO.Stream)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamWriter" /> pour le flux spécifié, à l'aide de l'encodage UTF-8 et de la taille de la mémoire tampon par défaut.</summary>
      <param name="stream">Le flux dans lequel écrire. </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> n'est pas accessible en écriture. </exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> a la valeur null. </exception>
    </member>
    <member name="M:System.IO.StreamWriter.#ctor(System.IO.Stream,System.Text.Encoding)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamWriter" /> pour le flux spécifié, à l'aide de l'encodage spécifié et de la taille de mémoire tampon par défaut.</summary>
      <param name="stream">Le flux dans lequel écrire. </param>
      <param name="encoding">Encodage des caractères à utiliser. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> ou <paramref name="encoding" /> est null. </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> n'est pas accessible en écriture. </exception>
    </member>
    <member name="M:System.IO.StreamWriter.#ctor(System.IO.Stream,System.Text.Encoding,System.Int32)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamWriter" /> pour le flux spécifié, à l'aide de l'encodage et de la taille de mémoire tampon spécifiés.</summary>
      <param name="stream">Le flux dans lequel écrire. </param>
      <param name="encoding">Encodage des caractères à utiliser. </param>
      <param name="bufferSize">Taille de la mémoire tampon en octets. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> ou <paramref name="encoding" /> est null. </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="bufferSize" /> est négatif. </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> n'est pas accessible en écriture. </exception>
    </member>
    <member name="M:System.IO.StreamWriter.#ctor(System.IO.Stream,System.Text.Encoding,System.Int32,System.Boolean)">
      <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.StreamWriter" /> pour le flux spécifié, à l'aide de l'encodage et de la taille de mémoire tampon spécifiés, et permet éventuellement de laisser le flux ouvert.</summary>
      <param name="stream">Le flux dans lequel écrire.</param>
      <param name="encoding">Encodage des caractères à utiliser.</param>
      <param name="bufferSize">Taille de la mémoire tampon en octets.</param>
      <param name="leaveOpen">true pour maintenir le flux ouvert après avoir supprimé l'objet <see cref="T:System.IO.StreamWriter" /> ; sinon, false.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="stream" /> ou <paramref name="encoding" /> est null. </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="bufferSize" /> est négatif. </exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="stream" /> n'est pas accessible en écriture. </exception>
    </member>
    <member name="P:System.IO.StreamWriter.AutoFlush">
      <summary>Obtient ou définit une valeur indiquant si <see cref="T:System.IO.StreamWriter" /> vide sa mémoire tampon vers le flux sous-jacent après chaque appel à <see cref="M:System.IO.StreamWriter.Write(System.Char)" />.</summary>
      <returns>true pour forcer <see cref="T:System.IO.StreamWriter" /> à vider sa mémoire tampon ; sinon, false.</returns>
      <filterpriority>1</filterpriority>
    </member>
    <member name="P:System.IO.StreamWriter.BaseStream">
      <summary>Obtient le flux sous-jacent qui sert d'interface avec un magasin de stockage.</summary>
      <returns>Flux dans lequel ce StreamWriter écrit.</returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:System.IO.StreamWriter.Dispose(System.Boolean)">
      <summary>Libère les ressources non managées utilisées par <see cref="T:System.IO.StreamWriter" /> et libère éventuellement les ressources managées.</summary>
      <param name="disposing">true pour libérer les ressources manatxpx`!tp̺tӊxxxvxv"ux`t䐀0x"t%Fu teu$Ņ3"nopup` p t`on t"	 QAwPAw"	"@wۯ@w"rT~  	Ņ/>Ā33"ux` t tU` t"<Ô@ewuew\u0t0"0"DEFwFED2DEwDE"u<   t0"01234w43210V~ "ux` tt "$p
wn
wK"<no"<=	w<Z=wx`_x"u t\ttU"@wů@w"ut  t"0wU0wu t "op0poD"0w07w
wAw"  s	"'xŔ0Ŕ"0fTef"x<"Ā33"0w0W"xvbx"xvx"u t"w"w"w "}``}FF~ """"""                                              U"t%4;t"ABCDEFFÕEP0DxȖCP$~DCBAϣDDpCm F"u5z 4<=KP8?E>`Wmx?$5>lopnp,;E:`&m}\W67{;:76$4@8pm;E:`9'HгPmN`Xu;{zx`,::;:E;`3d`5mNp'ͲmNp,ro67	u576e679mm}\W674p8ÕP?>=<x678Õ@=E<pL 
D@t8%448 䐀#
T4ÕPz y D t t 䐀4`=<8`t8P @88`l4 䐀#E`0PPxӮ@v768$4=<
8pIPD* Z`<u5KP8l4`%u54`Ӯv7684rI020P-x67=<;:cp;;p:=<:m m=<	m 4==p<vrS76$5"=<p =< >?"#48"=<";:g"=<p"ABApBÔPB%A3d@tBCAC x`)#"t&%B4rCӟ@CBB˫ѐA0BT%B%$"CtC%BBC ACATd`Apl"ABCDGDEC`LCD %3/>EFEWCD CD<ABxvCÔP1EFu`sFEACBDxuGGp#unoDCǿxFE`~xv"WXgѻY
DXWpҧt䐀0Y
T0 "0 ""WXYZgZYpZYӮxX$5W8[\\E[p'"""\["uKCÔ@(oCD"KDCeCCDGKKÔ@LL%$MLLKIJP"N` %$MpJJpIuLL%$MNM@MNLKLLLN<M @KCEFFEWEFoCD"KDCeDCWCDNEMpIJ@Np eKp`AB m GHxEF<IJunoǿ~xCDJIHGm rI0.x$4HGPLÔPJIHGcpL>m$4JI	JJpI6}ru$DCC" "JIp JI ABBEA"WXYZW8u
$4r Y~  	$>l [\ gp'Y$04Ӯx}| 8 [\XWÐZ"cdfgTu0updpx8e<eßP}ƯdcЉeu0updp8 xfg"iӊxt,4<)})`})u䐀  t_tth,u tW,5`)dp"u*5yt*4<sB
"u
$4s" %3u
$4s"x"| } %3u$ 40%/>"u
$4s"$4=<"u
$4s"%$4<"%$4<"ubr"x$4;:"uK48 "/>"xTA";$5:"u
$ 4s"u$FE"%$4p" :;"x"
|  JI"                                            Uà la fin du flux. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.IO.StreamWriter.Write(System.Char[],System.Int32,System.Int32)">
      <summary>Écrit un sous-tableau de caractères dans le flux.</summary>
      <param name="buffer">Tableau de caractères contenant les données à écrire. </param>
      <param name="index">Position du caractère dans la mémoire tampon où la lecture des données. </param>
      <param name="count">Nombre maximal de caractères à écrire. </param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="buffer" /> a la valeur null. </exception>
      <exception cref="T:System.ArgumentException">La longueur de la mémoire tampon moins <paramref name="index" /> est inférieure à <paramref name="count" />. </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> ou <paramref name="count" /> est négatif. </exception>
      <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit. </exception>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="P:System.IO.StreamWriter.AutoFlush" /> a la valeur true ou la mémoire tampon de <see cref="T:System.IO.StreamWriter" /> est saturée, et le writer actuel est fermé. </exception>
      <exception cref="T:System.NotSupportedException">
        <see cref="P:System.IO.StreamWriter.AutoFlush" /> a la valeur true ou la mémoire tampon de <see cref="T:System.IO.StreamWriter" /> est saturée, et le contenu de la mémoire tampon ne peut pas être écrit dans le flux de taille fixe sous-jacent, car <see cref="T:System.IO.StreamWriter" /> se trouve à la fin du flux. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.IO.StreamWriter.Write(System.String)">
      <summary>Écrit une chaîne dans le flux.</summary>
      <param name="value">Chaîne à écrire dans le flux.Si <paramref name="value" /> a la valeur null, rien n'est écrit.</param>
      <exception cref="T:System.ObjectDisposedException">
        <see cref="P:System.IO.StreamWriter.AutoFlush" /> a la valeur true ou la mémoire tampon de <see cref="T:System.IO.StreamWriter" /> est saturée, et le writer actuel est fermé. </exception>
      <exception cref="T:System.NotSupportedException">
        <see cref="P:System.IO.StreamWriter.AutoFlush" /> a la valeur true ou la mémoire tampon de <see cref="T:System.IO.StreamWriter" /> est saturée, et le contenu de la mémoire tampon ne peut pas être écrit dans le flux de taille fixe sous-jacent, car <see cref="T:System.IO.StreamWriter" /> se trouve à la fin du flux. </exception>
      <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit. </exception>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:System.IO.StreamWriter.WriteAsync(System.Char)">
      <summary>Écrit un caractère dans le flux de façon asynchrone.</summary>
      <returns>Tâche qui représente l'opération d'écriture asynchrone.</returns>
      <param name="value">Caractère à écrire dans le flux.</param>
      <exception cref="T:System.ObjectDisposedException">Le writer de flux est supprimé.</exception>
      <exception cref="T:System.InvalidOperationException">Le writer du flux est actuellement utilisé par une opération d'écriture précédente.</exception>
    </member>
    <member name="M:System.IO.StreamWriter.WriteAsync(System.Char[],System.Int32,System.Int32)">
      <summary>Écrit un sous-tableau de caractères dans le flux de façon asynchrone.</summary>
      <returns>Tâche qui représente l'opération d'écriture asynchrone.</returns>
      <param name="buffer">Tableau de caractères contenant les données à écrire.</param>
      <param name="index">Position du caractère dans la mémoire où commencer la lecture des données.</param>
      <param name="count">Nombre maximal de caractères à écrire.</param>
      <exception cref="T:System.ArgumentNullException">
        <@!A`Ԗ=G6yVP{RLn1K)=&;< }/	{~ڌ6WߧK%穢uy\'oa^z7W^8F4C`mfzbIǊg8.RT@<ݚfr0q{޹I'ƕL	Uæn@֯ƌ<3-XމF	:x|r콙qrp;J،xk@5B{o_Qvk:{1TuGGbI ui튜bVNH0ϙK 7$Dbʙ$2r?[0١3 ٨%;#oMgwCcA=aiM~WVQ@oN~$>d}=09Sa
z(CJSZK{v*P=3p.R7?~D#.\?2B/'4چ~iH=+PhL=Ě}R:eAϾ ;] %g[>T.vήOPoZ	|%O)2(턷N/ܪįe-贪V .E\|Je15!0`uz~q<PEof݃X0cI>{p#mOdÕ$Fpt䇮:yLPa8Pt0-HAרs'=[)b޺)ߴa37NIBZ)9M`gVomۤiپh٪y<.
C|"'\v#dsrC
Rdw!<9Utu3jIC9sL#zr456*2^rHO@+<9@!t`qj[I"ʓ>BLhJ|\s:NCC)?g2Kk<ge,g[7Y֟k)h}GU_K{4E?Ѩ2gLJJU;|ǻN]ր%kbL̥o͇3˘[\axVRR/=ARg'21	$oS/AVqZxdՌݼu#MQ6<a4M$+Lo	Nr}l#4"Y^Ia/`Nqa5s۸4@9);d9Rk(죰
C5<lh˛:gC8iCf<2 >Ώܸ%ʭo8cOTDR~'f*^;%Z-pMh>DMKog>pSQ-ܴE8!]Tf8 1\S5t[Uqn߹bpgdƫ0OH(z:	D$\V :1V5bή11gIdD1,2ETs)s`ԅx}҂0Ѱ_zmnmW<4ԏ}
?=է~6R=}dn{,ϘiʍdQ;ZhȢ(Yڙ}e{_-'W=o;Vo-fr9^C,"9ŸaZq(՘v@8ʌIiK.1(*K{nE2D/91!'pf宔ZzY}|TlӁ'~3
{Wlv7ZC]@XL23%=c*<iѱ$|uY[`Li"QM`3Ӕ6lTO{1SxkQ/tY}H 7nwyӵDZ h.{p('~Փ
W=ǖz4|6m?*Oa߬bCI4MDxʹ>I8!mfC!mc_C؉đ@v@PgE?kӿIg?(p{k?f7eYōXE`̾ݗikmhMT~]%PZ&O+Ԥ$o|A-&#Y;Z}Vl_z0~6f=9yJ{~EEk7}*H\+X
cIϸȃ	N$BAʦŒ\iV4t2-28&K!a?<dq90AfK;[F5 ۚ>ՍӋ=qE7/cv8zM`MYb
IҼ4?tTON1+v$LJ]B@nVfK9rla@ڸ`sяlЙt'ȽjLp/)㶮m!ӫmH~8&Rmw\Wk볻֠4&`;
b2{N7{'|aDXTˏsc`X~>xh]5!("Ud˥9gcdO;Cb(NY힉_8B)hG"&M_֞?`LcŇoxCVvαB(`pAm5̠\ B.-uF*;[%A"Klf)0S>}L}n^2҉stZ`f#{Zn.>2똚/Jq0:b?ANRaeZIzD֫s<1H<;|&_q'2JR#t8:CW?:(p0^:jmT鉓Jխ~tooorV!V-qύ:KXHS]7u%`[YI+Ƿ6mOl_lU4c#a9;U2sJ!qju˻KݜFrOqqCY3e(qbYETzs}w\{9$uD;e$g[0丌U<Ir!~q&'>wh9MWAFz;r!D#rٵi#l4Ud 5Kͣ*ѯ=Dآn5xo%FMp㝏DY?Įk5|TLWnEUʙkeL K}o0<xHڍh|t"Ժrsݷ)ȗ G8-zfjF\R^ڦIk}\}!-&Fli	&4
`i>Qy6ia&n-N0@<SiTR\ZQx]y5AuQX
6m4vMŭo2oswW#.sko/ޱS'[G`Pqr*)2w wR8ZZh4|~%7Ny)GCH_(EJnZ"ѐ.*k3D.Zox-ߍ8\RB_2[~'o$=".+ Hk\V]^1nzgW k{eR2|Ic"e9ܔ90JB~>iAMh6X7ض+a
qǂ>L?`@E`qbYca2=Ōuxg̴Y]RT¨|KTGtdQSLӾ2=௖+ٞDR?͜^/frqb\w
g0jjLx eF悤%UMLA%="83grWJ-i>>h*6^TW@=+biFH6Su	Zơ.}BTuJ,&l14Xt:Ϭ
-04(VTiJc6=ˎxͩQ݃J :>Y7¼ZtU-C 4ctͽP8zI}DcKxB=>}}'v~oox$&f"|\c$vݶB/!Dpr ?ap; (1pŬ".^eѤM^7d?mGzF?"|e0f_K6&0yB$\j`rD-J7Q>+Pf=D<%=_"R_=&wi.e|\1$]`\bc@nӏqeRB$yan6oGPNGJl[of \ĥBtjRxsƋEPHr1v";?yL	TFe!,1%i*%e*VEo't0|j5HKUPs+Bv%9{DDm\9.6LT[y^&qж7$anɑ6"ܚWۼEraF^by='P˛ ",KTCOzG<@Q.0ԐGxF`e0-Yer_0w%\xO֝K4uzMbkOL߱ÈRd!y/r1ψ
Dz0kOqHz⑶;D;.k!ȯt#B'aI[ǖ<wGːrRNqwfrETe9:;6-K|*Ru%I8\m8 'ưFODb$.=U#"U9$FE8BHp%	A:zm~8ET/6RuI\CV?Y779+언Fd%wκ0߭[6'vaZ*u_	˰*\9%AO]snN#yUNP9lv!Hu2^8[1,M͢A@;׽:	V23-r\֪o$cp8Z;4ëP]UyR"ZI6xHKR%tZ߇Q"lB7LYH@ҷ?#&qbW5`b>*+y7o"*̵2&GJq>|7m<$F4>pj99LBK#Eos=Z3Y5#.|)/m$5>Yؖki6ɊlS4b<ɴ0vHk'A4*tqCf({<YԚ:(,xP6&Y7йRĻ@9U~ةi䓭#0U9	껊N;B	nnV--zS4>?QS|bf<!/jD%7-ehH"t|7TM<ݖƀsUwX)Y!/jr?œ7Nf	 N.iUE.s7+wyA@YqQL>`'ıL2n%ux?^&L4W^zl0uqp8cAOOiT1|_0b:t3fڬrc)Y*aԎno%V*#:(A©vi_dWKFlێb"ٟfbP3oHg8Dsu1;3yV\5Jb5]<2sARڒ*~E&ʒ[xQENLH	v+^ִF4tIߌj+ B#$]:V`P>!*ĺj%kLIr
Flt,:	~gVSb`S+x*4౿UӞeGtA%^ZFV,]ait-Qr! 1(	_~O@%<MۏpXj;?j77PMaq3^r1O;zn[YP|ؗv"qd8908@zF;ڲh&/~
\wƞZMAYVi=Eqd֟gz2o%aoyAtՆ_pt<	.5)[m*_Pz=H|p1Ǩtpf([_l@ONÞ_QMj$ҩ:
>Vf3.1{07_Bи):C$Wͼh+]ANq	eRA(`X#/7?6Y\73LYyNBtȶyu"pC\10y^S&þ*#X@B41Oz1SS̊ݩ I 9S {RDq"dB!bYr=[X"P6.؜aaa#t&݉<rZ*#܋{ʸk[jTG])n=py5(>2/j1ꎂؼ̞IC_!'_#f(Z{G|jȣC~<hriX#;SΐXSVgbΥPIe'O&XXaěd2ސ sr
*'=aqP[M*"3%c=l~˺{VI0-&:ۅY
̡'eÔO#S[tŲV5`ۥ蟋O:ˤR6OPTX }c+*AyO_	Wog}m|H =U ?J"Ze):Uz$Ru,[囜UvKs#s;Tg]	VVb`;0W-[:E؈eXΎqDLbwHazܠZD'.9R7'*@wS\\xVEe/Jtf Ue\{^	iю?{9.ck7ODyGl_	-kz}UPѮގ\H)A\vs<M@$%@w:CJkpzhuM,$ ^[ɟ~x8Qd1ӕ鼛tpuprZ#%8h>6v#]n&Dm
%"Nbi|ĚmW_,lKõ4dEZIB6)XAvTdZxFɵ[P T8z!WV^=z,GjME}Bap]t{nq[`l)*`w4*T܁J]k'7T))xIlg~ җ?JQEg4ڌ`:K&nwc@*;Wx5	EO'3
 Z'4ƪUWٕ; @^Y T,8(&XHj7ePOZP&v+CM=G88{O᧧4PQX`ܿ/`Xme1c:^3mVW,0jG77ߒC+Y kT;Ӵ/%#dJmmOn3g{{7\3GׂB<L+w.G )mICC?"EPesϭaH("'&$YܕRK/kZM:oF5UrX@pԮsF+|@VCwqKhb]`5	[fG|CG#M6:oN3q)M`1
zf<rR߆*iϲ#F^sjsT/@{-#idM04w(9BU es ޯzR_j'QPOϦG_E	8,5~^l(/_9'G=dЬ|(Dmv;82O=HǙ|m&<y4iG;c`ya-&à,cϳH=@׹(d lDKG+l++DAԫZ:w+Z&%ip:J3-cl|{OaOԯv|YOmQ_ZX+Wa,3yy-ID/b!h\ٔP١X+*f^.CE$^2a up0Ǘ,.ޛ&,׼.th!dSzǼqz!߅y]]@!JcaI KL!I׃'zn
)fT$ 	Ty_"{KR `܊,s	9iY,(<lΐp0:VW=e^D.֞jmWv7<CvWj	("l^j	嵐/wqNr˯QqrK#x>5!>YDl4lW0GHn')31 R(excH$ړA',i0M2ow9  	Nܒް8ޙs;)ǣ2@ v6kuݽ6bzZVdn_"XByЭKS~bـNlB-R?_ŧUa	SR){(_S&I$S
u<IWP{y'vQڅ+е>U@}VCSl$ݕAmn誅@A@x-&BnKDQ,=\zA*;)bRy8oQ@v+*iVMIp(JJplW",^ǑZ&pW^;0~@-:oi׹HC =rX.cRr݌xpK}chlPD.uӇpƴuh~wt2{	_ɂ]ϪA5=+(hWUOG* ~D.r9mϞޢ?Իf	T5tH[Ѝ&Snq(EؖmXtq>(ﺈ!J9s+xiJ
I.\Z%At@6aCi\LVֈTK1B4I>b܎O$ch&ȤF6<2*φ`2-]dPڭ)Ax(iT`ꐫY+=O&聢< [0TfYu-CPvj$|}|ovjdZ
/@NwBgQP[G:@_;H{w?hts"QMKhEem恃0B(?Uo1 P+V*wVHK5yXcčA` iKcUN.Ms^x+f,C
~tAQwX	qSL5I#ML](ޯ'-	˦vjCJv=nXЧ#Xl(,0O0k,l*XJZOɡSȁwpiYВqz%u݂Hj'08;A.{ "Y]kNLKTxi\eB"Ĺ0^Bg2yg]I5Ma>{7
HzD/h (fjᘏz> A;8ԆB	1.zk,0Vң\x
N_'UnÔ&r
//~9M	xoF?v# 99vxۘBՇI9n&xWw;]KΌeney(ferBW=ps9Upl	oAg'(<ΏQq/6DSDkĎdV];"e;E',n@K Q$N6ɫXUlchvGSr^_OQ1فSzd}IѕR}Ն6dܵk5)<e4KNSbb:#\1*g}hc6йĞ&Wt<;mwwѢ"tʮ/΅޻f0Klg74Mx %JgOp,ɕ"U$J!C"jmTJ8S'mcn޻se]>幨C^8\sb<F.:+|^Աʰ$%$A@~LWi~*@y@<X a%)b	YnEn-e6gEZ\jIwb+22nڌ0Yяcvyˑ>J\k|ELChҋZ"$jYwPFD`N89fgU%^aؔ?/"Zv6n+3TUesַ[p$bZ̠	~{Gu:7de*A|!
.bJoXVӡ-y-%"y;Ơ
UbrS~U$v"w$v&x-Ij]%~-(hlPWC^f6r] ؽ**s*Q)4]㩅:`ߘgoJPC&3hB5[Y֘)>!5>HAk?ta-VgáꥣVg^E8KT[F&Gbq8Ù7 ͽ\F 𛕕r|,<-$N@ਪtQ06«:anS +R;FTɿaN&)
nq9;)ÿnQFe.q8Y48U2WCQ:A*Mg|%CZZd,1gJxພ~tIwo#/RJM)]k9ɜ6O\Lv	P]Ny9:\C DF]);	b!78Nd,yCGt6(w] \D]]H)4?kk݈̓G+. ?Ih }z$mz cą/ťmUm1pd#Y@R@Mw]F=gC 	:):`R*6F} uHw'ˑZZbPaҢhބ{:k+
:7[xw5L6²
O;Yp
5w 'fqR	PG(-cEofg ލ
RW}CėW8>ŏRTmJラ)ɢ6t䒯柪=xs+;ʡ)5^M·xFI "2a5cwv#w!?3,&g!8)¬H.i񈌆kuSj~	v>T;	3/+5&sgEUX}LUe&4N%ͷLOjAGEZ8=J8zsʴ:~[LA$5S>jf [h.Ƶ|t7
ӊfi]6Tft`.HJ[Rt7dTYWa>!
}ȉ	<p:yn.w˚艬s֟<QMU-"\hdYǽ*e'DXXoe	Q.cZHE'ۯƻur CJ9X.~`OE<k|ڳ̈np=+^zRٿQ+;H4ONpղ<@W}; S@90]I8'1lWw|KMf=ކJUj(#W5IbPd+4+?
o+_!''h1'h(qUJp=M<닑3x^XK1 7#5(*(nbb)R7p`(O[;HCnz.2X:#%MJoߙ.e҃KhSb+*NIsD:u׈Q_ULK=CtOP&M8dSW6Tgv(NMː1hʭ>6L|*y%pefA&yt	2])U ܀1Va+ҿ9x!w")sY>kNrط@Ek$Lv ^[/{wpY 	<:t*UWJ wyF,X"Dl7{MŔ3g+KJ+~8,0~dΤLU_Er{qO-Rf^mc10Z{Q@Ї}!4E	Tsb#¢]~yEbO-ytG'[.kd'{s<X@QjL3$J@=8<3,DPYk+>̿xӀLƒV$wW\C7,j(Ro0bp.yjYwR9%c@XG5K9lfuf7pAٸ=Ӫ&3> 7y7s)-0wTà4s
+Bo1R%~%(oQOk|4!IHm>qWXΡG AɠS@^Og.]jO5Tj{^|
~ndny^z+!#KVݵQl^lfiDnR(U۳1I̕SGT1_0Y9%8 ]`n(+$oJbMCM9_c͟O1wLϖO{ӊ}y_E
,(7VX;
a%yWGvENZfƚ$GG<!UϛYlJMyAEǦD[A{|YQU>6gSbqe.+E'0B{;i.{mG7̳16^P[∏Mv.?Ow+	6P53S*6ǍB	6x%\P8RPx<QY}Ot,00X_#,wv>s­$g;ix\oXPweMwx"X:+:lL2WTc!	mW̠V?ڙue[wOon|"\-4Au1j7Na,Dɖ&\nYP#}!ҪvF_JΆP&V:aqo1:ǊwXGbtd=Jsc6s*UJ'ȬgRBÙ,*nHȩ]k'>rgQJxITb7*pg öfsd1Y#j֡Jf/buCSg*dA#''ـvT-S,


b**0r?0hi].WEVq^s$_)1}g5r{>*F=e
(34Ԧ-mZm?=e"tfc[&י6;{!aRkuPc9e//`| ZUMΕ݄)Ǔ9]np^}^'cZЂ<:&x<u_8-7q; 6`hԣ@Zg;sI*8|npMUD2V~}~7ZPe֨{{9aAuXu[v^n*A]k魷zJwf9gdAfgkxlA8I󘠔 |,kћWdK>:e"	SI%\/wU9y0 QO)6͉O讻+wȪ)st>b-2LrLVPeD3ˁ)@߸?G_4YsB{fLyjq{@xlNvGZ`"*·eLRZgfk&nc"籗Fa^kj!
%^,Zv0auODjJ|^Al$Y<SYl%]V dKx!cMIδKpQpڗiFc)r,KuS+tY>c CCRLn@+pkbL$
JƐFM S*Ɠ$3)ߦf4G`}bČ]˭J?M__ <oK;{	E32ߴmHNVYZI~A6DV R{(oYƤH}Q)$f?:FѺ^qfz-Sy,zRZ2obuܷG2;`}]!ҵl9>a{u"D?ѥ!S!Df84T>U3Nni9kF*%ʊ͊O)GR=zEOοA<g޻RTodcGYD'){Aj]8uce%]UU9hN0Ӽ#׫,=aZZPKxJZ$1xj %dF PgzW0/q1ꀺ}5'K]vӳhB.APue-ҩLO5\>ѡeyc!r˃q}!~׿-7WlW%K|珠˵EVȦԫE|+qٙVt.'Uĵm63]V
j!iZQ+rܞr6~4
1T|X0Wf_`>d4\??i)r1C6E}hR7LZWͨ
Diqˉ%Pfh!E_S{dN<X*
h2O2ؼ0My*"Wv\[e}.B--`Jb@|j=m<tY<ׂ1źhX"3BvMĢ([Fš&uV]ig
,8Wl\'>"2Ce8>?+%ͼxfS;9u`LNu;/e^@2&ɮQqm֗ܟ+Us0'dE5'Wp:yt:X68ɀ(Dwpw*`-LJXݒ:\DGFFF
qja*Jr|`Ưp欝k={QآC ~K!z_BT3g1#gc:3L5_B/2b/b SsWYQ0GlQlL[crb7Wn:V4g$M_V H16C,EOԿ)HטAءjO;:0V=mENvr{UVI2خeE^tCz^4MA3H5>_0/tcZ7]
M+rNy0k{C7	=bM`>viouPR+yq^^Ǘ$.e
'8y1_fn$Ek-[<!Ntڟ|KYf4;{x1>Ӎeb&G.ʘzJqlg;?)guM]mC1h5ͺZ[!EЄ]!5E-[Qs;i(#¢\~ēZ3yJG0,6ݟB9XTo8^j=X@qjL2J@=:Ui_lPK&+>̟tۀLXHi[G&z8kJhbp翝oYw3R)*	f%gK
Dg0l{dc6pK`AOFB 's;L(r)Y|TÀv
)BoLݳW%^}()Ak\5!r`w{ZN؂jR'tFiAɀS@Ql#MJO5=s~|Rn~nhFy^{GbEb{ JI8{!m?!ɶwR(U1IܕS)&zT_ޅ0_0Wn~̗drf ;66vկ[)|z!!\? `|b/H1QӮ:elpOt3%C<LjncX_DTrو#]p-bIuNa	$(YB<}hW[]!- u+q#3ocQ/ v]= Nޔ&8\+cxl_G~Cndm
4M/pA1=Xi6Y93R6LXmi607Qx#I?75bdY;"T_0akqjJBg>:j֘¸GH	WFԋ@o-Yq,EܻJt9sSs[g;_ŸGH쑚=|Q$c1CkҢ7E35/)֮mv̹'97 wB))ٶW\rRtYq Dp{.xt:2eZQ)G^@x#d&pY@ZXUİ6w;riX+Đ%g TB)ŚQRIjD~eǶ]SWgS?)Tf *J 1,fC>c*7Ff[rh=#d-jgEdd^X- m,zy~o5F^xC4WZpSh?iU4.Vc(3:0$-bhhPd,y5XĄD?kRjeMkASOͨ*R^K.4BuxhHj6uMVbf`0a̔(1~hFǢ׉fU8n91,F6]ό_NS
۰Q>YvH78kNmThEad!͂߸	N%_jYl9UO+\$
[iٴ;>|Ë%67+C$㨇ȷ}a'Gq	A1
g	-{8O&mug,/>deS7zLv`y(A0v_M7QmwOHCi?R̿զأdghsJYi%ژ)1+qޤH"Ksac*a&y<#'8s@,+3;KrX̋ewP&.u:"rc{3.n-DlknW7N/0;ڹ,5ul`;[25	d)$IzD/ЭS!?u:Ŭ؝
`3*+5@dowI
!B,["e.!߳%%jnF?Agҝ#29½ۺL!HuEޚr]Z"z.(9Z4aQ.?I}b<y`Fuɾpϧ<:ǣV-服5=
U,8e{&f~\
ol4}]Z{2d^0Oi@&Y;z.Wzt"2^r1v@淬\_o	3N{,k]R6L=2U{_ J'Z,iU\ vi]JʬcjL*a@o`u;Iyj7&٫Y 5j.|zG6Ȩχ+IH#]uhd)pzUS'N*UҽuQYXa}?72'</a#Mup֕ne%(I?	}5вUx\NXGT$)yE}/B/us"ɫr
a{?uAg5[QيyNgijlRUeqցNx_C>n2V}D'}řВܡ1?7^˅ďeZN:TG]z,S>4Di`QdB╾7qw>e:KQ1]λyKg ]1 W)g1<R/c#h!i7хP6aHtߦ _ 	,xњɪqKy)Fh&Gqx¶4\MIV%(d`GHkD\8 5LQwHr5kEuݣr=PGa+jxE7ΚEpȼ͖"] Ϲ[pxNM#lBȩNPUvJpsKZhiћ|⋗k6;}!}U[$*i)sFC8pckj|7DܾsJ
ilWa,Pt2H  urIc*jXuyŘ]cbHϒ3ȈbY +!epS(5aa2`cۮx+hǩ~zO3m zfX3֡e1fuKR	vt3x-9RёEQN3M"Z22NFd{v[I6s{<Y|#Ez/<s!q-8)ôQ|1p?ҖT144]c(2QU<ƋdB_,rbB"Oܟ])5OzfTS\)x!L:<qo$h5t	Q&V+X_30efJz?Tx4dcI?*D ZgS/)mب,;b56Gu*ע^0fAo
Nsk/T,ӌ]6@PN'{
-	4hl~URQYņh
s!|qCv
ʇBƾl#Ɂ8퀠	o3ז=G6y~P3RLn2ʲJ)=&;< }}/	{Ц6ߧK$硴LFWtIIjS[LQGw39F4C`mfzrDg8oRT$NչWr0<qI ƕM	ՙ%?hE[2dZdpRM(
B^G	:x|r콙ar{vJk?@57}̫{o^ȝǈqk:60-Py=i~֋:_bVNH0ϙK 7$!ʭ2sq[7٠3Nl{TZl 14%q O(͹$Уl)_c4)2\W4-Op ⨐ruJԑ/kHYN"
]Yc>!͂" )ɤu~:gZ/^aKrVZB[5Kf|zV\b%/GUޕX>g"GQ
fUՀ|ιZoxHTW\I;a`u^SdOуlܫEQm;gI>oJFuY53"LĒ sΚٽ\O|\jY\P2DmUR=b9N+yH[hD4{ʇ%rI;HAhi c]ֹeh:yZ4A=Oh/ķ.<7(ǟ٫A 2mɭ˔/K$Ke5C>mi&yUCo$'!RV	w-k;omDMx{|k&˴ʱCT޴.TK)4H'[kOq8Θb%j=.FzXl%	7I/>VDv?`<//KwL1>eBIdc"=9[vV"43(>+M]gxq#$8^;(<Mu;0$|/!/wv)tEit7RSNKqYӈ:j(Z(Io9iF>ְ՟5S
{/o$dǨnγH0}Q21Ve#Zǌ/vc*Ͷakׂٛ愱>S"Ee[ I~	j<_f騐OMǕOc?W\j.2UޘEt2-"WڎG~U`md'Wi2C&6V`6q-A!s<W	=ΐ.?7?55
07cж]ALĒvZ9W=UE*|U5GY>/^H-/Ph_K:iVzc$)[ԃMfbva22	1	0ñE1$@N UܿGC$'(iӤ#hD{2%C	R{QM)!?5=WpNV)˅e~2reBΘ"Q`
k%؜?n>D>D3EAs|T?/6)aLIy_җLDܕwׅog?j#qS]h6ZI(M2='Sas"חC#fbhNWڤ`3>4kh>]ALIRyCPnÁKT{.@pFOb3?mÉ̫拏DL:"?|^w6dn`W{-:sD6Ӷ0庇d?IZR%L!EB]"9hW Z݈`ŨSmQ$*peAU ':O.3!꯽39":i<6(RUuٕMt;FQFZ7G-̚z0s<63c3i۰d?88oWc@5(EIaLKhj.2Ⱶ9]FSN1Gv#' KAG%ŋ=Y={g.|r'0+ac%W/vs)Nхѻ %^w
@?m]]mW|=L?%C|ZqT	0aގ̦}m-V UI\Vl)2̛ukY^rJton_gT`!!ȯhY!%'kfg
_+%vǂj[ N.FlkzS~^^hHe`M0(ӳ=|zP8CDRUkESHgM[HruĎ(q:ԛzjܗ{9"p rwFu?灔zޛO>SҺ	5~ATՀGH˕3`ff-3(]MO`AΎL<rGATmo쥨fD!$pC~$펅bw.q(DXF^uje.ǽaЅ|ytSY#;$ky+SV2>0-)\Q	.3$ Iڱ4nfbr7kĳe`Ӷ
t7.macR<7"9P<bN5/*̐J\wܵ;<M?/J,԰߿􆃅\PT1Qga" 6hI%%Aj=
*|wXYa4!?1g96E{+w+9X'C<gh #Oqk%2G[]f%3JW@,bkV%:"8#\	d7HV:-ꂏs@r+$pcw6 Zߠ׊Pz҂?N	H_( yMɻzWM#'b1H|HK:?#t~{cL9jWETTfps"h=eWifE\=1]hG4c)%*8`L<YXe\¹/DÊ! aT>dfT+ts`-V2o[FPd򟱌(2oc~w̟bRl+<Fpr,r6zzDzt،D
l9hƭϼ}WjҹIP;ͨЏORkJYthG+TmR3P{ Vg12~s(6⽲Zɲp=D}"Ŏ2?\6j_[IX]j#=voYRL۰[Ȝ	& cdkla|I0͙*S[πTuGk:qWEQlOq,\<7w fRP+P~$u_mʑ֨(IXb[deRf!S\]CqN;wm&Xna%Ԫϼvd;ARhsK۱Jnɤ^-jHjQpV)a@+ֽ;Zbݕqh(l˫]btI:I~mKL{e1XF]~MD.(&HEWt`V)kB]m|.+F^">6+O
<Q;XA-0_@!E|t9(#<ƚ,ٜzCkXb-&JztJ޵^Q02la?}s\1zBZU08Ga_-ʕˇ@bvBp@VjV2%PR.$`f,VW0x<Q/nLB,s @i>FҔOyڒޏ`Q!|17ų;ɀo-vޱܽ#@43!pP}&~YpkQtQ{)cY^
AF(\k9w<ѴSS[om ,܊Yjitsk:vî"`kw0 N\yN3ôz#^mL3s~BǷ.^H$VY@勐o-QX-5C~N={K*אHZ5s=erҙ3$^]=DME"FKUWl=(TퟂtS9gr[b0K%eə{{ոSI]ya֭fq挪5γ;9+aU4)	}5Gb6P ɧQ{/X{b3\*q1K߀;`l{G"	k|ABcꘞbύ13e8Rab
J_X=M^ ֺϹ `*S6ǯYb_:7u~pbN̛3:Px)|>ŚvN'IdEIbP*Ak&lz.FkǟR!SVGՉt}V]XLUL[Y[v(?<K$~0H=ƤՁ+AR+g'&{ֺ9vԻPu9ck9n-A!"M_Y~N/vaF
f[U/71h ;TJ-Mn!cڤxsCk]>k8XRF
fD:4-.l|n{4%mcD-"\R|]<3 V]0I j`wb>x5+}pjQ?ۺz^S'}+<84dg5yI](;RQ7Qč2sgP_R:q_ti$5OĴHEW#ώRgK8gjMx[Ey >RE#	B3T>⡀XɢgVbػGP
8[Ye@*	@S@;J%snpT#0Lv,:IE6y'NXI1`/[ʢ5`TzG3:sF	Htp4BYf8N*>qSk.iUcJԶнyدsOq|yp$n_Aw!:G Je-gxj0/T,\ 4L掴S;z}{
Npđ&,V̦-*P/e#^3+tP𯼶GRTf8UBCo\/'uOM_A1."d?-t3ĹA-^{>6J_m[MڀV<]q:K5C$¼K#E~vZ8YY:aMLnw'$hmM[I$ݛd$adBƃf ? +^,yRЯ:Xm<gzj
2Z"u|Wĭx}<IdWwx*bkNe`tSGYCƗE3z b&yϹ<3fc?7'㸤u2FX
}~%gfĀъТcw7յ1z'=Eّ;\f+0y-(de7F^`G<N6A`RB8mO3GxihP?dА[%.++=q0VMAIuBp0zbt]܏BdtQtl1|eԔG5"pJk,
"@DZ	]8LVҚYYS{aۗ
u?|r	֫vj*Ѻs PNF{ܷ>+!=/2:l3՞fމ$Q.X=ٕD-J9$RQC$0jSSW72R9yNehINrxpal2^Mma'lfYUv39ឿfy\ޝ ̚,ͰF=D]!$L.|\ҔTe O>+Mߖ<<}6G-"0\J2CʻA;^eHCNuSF	ՓfQJ;?-7-H$HABJr	0;?p} LuTIa7;->de`+!	\X܎bux
,Q-&+YtrFdX}n0FEx%dt@紫\ʎuxZHI_|Z{m
@zuLB堘3t}9ݻY٪<RS9;DgZ kuoXyx|sIՠȑ܍B7qdio˽rr!s.< Ӛh$rbd`kw֎i{|]NǥPؤ@%"]e+sKO9AOf;pC&I0e47gHFSS^:``+U%" 
9gd5UmۏK*݉^j_F?)B#rH2rqfi3"1p
A*ͣNy<W.j"i	+dgЕcJ)ӧ9a\C	BNY{e	={pΡ?@]{˥ŰnjKܨ|VŘ ev]?9N"LfNl+
r
{D'}ɫk*?m5#MOSҞ0m_\vt#P|d,:4q}TؿIM*(R+|rS'kDqV
m)"}:ٳ7Gi*7h QM9~bU4o<}q!_K)(njؕdOk}^>WCHEzV>ZQdB1y*U{?=ISgJFABT)2<O| K#zIyKNf1
6:x+G
A9]T(}I8*V(->#r1\MK)kRYGAt+ZS:=@Xܑcui`Uk&z̽k&
=LV V6ai Y AۻyCbD%UR={\[<E&Z0Ƹ`q¾lٖ$^]ADvh"E͘;zDa#AZ94{~Pz/F@Rx͝j ť֠QK,._ukŋ$-Ol8uv@y	^AI䥵:9!S=2R%71Q*u(J6nB
fւ-E'Z>sfī>!`f҉Lzvy{;\'nML13"tĀјCfH@%LMA1u6,`ay[~ 4!Ť":F<mmײ̦^_껫VRxvDS0zq@jNS]y(kq_	^|$p [p o/Q耨C^٠C#<D%im𸺗O/SY |Yyg|՗y/v^Db[ȱ.,˦wrMRgĤj7.~L$ƻ
W!y朗WhZ$VD6BhH|p([F0K~s$69HgJc.ar;$0ϬO=I4>܊$(YU͐K$>6[MJBc?{~)8Q_>J\<).42AzْH^ Ӽ	$/sC*?m/EB?R\MR}-1^SK{25F:N.*E ?W VBDI!PqUwhx@zq	ʤнaJyo&[x#L3-zCd9ЦMSPu<'idO7+O& >Jӎb''B>F9avOza౐Id	C۰UZm4?aSN'|źuW[зhBF]8q {h:.;mp3)$hr*%>B9@P:*/B\A_*I1爰q鱫ݺoKX-b٠^~<+4C?mjd.OGӉ%4SbDHJ]."5>2:&-b! !>Q4YVsfNz&FEXH;:pPjOgP/olfY5yS{lf:jA'!DAș­HAЯ	r-B~s t.ϤL^i?؃&Mp4 pc,guWaa`Ueb?7'{璇$Vh *O?MgM#m6̞
waɫ}&+k§3Y1RٚZ`kҠׁE \P%#5ՑaT(<,J,8j_qWd[]QlJ)x.ّi83;;our7{2!(zs.3w&ZjHǵM
7p2A'U;_󻅋C6?PD2X;IbIZ/@Dxc.XTdc#Y'*}<-<Y*{ m_ǣKh*_:TZ!@gUGa5	gĹVxF5
`rH ㈎~rϡӦv"&w졯q:1V'1Ph}xg9ziU$P,	?ڼj<Àa%{G:h5#!,֎|k hb߭FCuq㖦N(̤|;--WUc7O55/{3j'4B7"CW/0.\nlp}niԻr YF!?$"7nx𛝶>'bM!a
&r]Em/ߨҩ TASt*fx EHPwhg仳OUH»ҢhJ޺\9Fc>.n wxbb¾oq6/i 
 +:[5q:lJ%%j$ &@"y+$[R*4b0m1(6Z7&mR'{"|1S
ϩ;=n&W4و K:Q4}Kήo ħ7:>aL=+سC?rW<׈omB(ؚgQ8KCbԬJ,V\2̏K$ }=$Aoz9O!a.Uw;c+Ln!**3uݗ<_%~ˠ̱'zD:F 4\6m`/XXV
R/Y.h,>ֲ^cX
gGC"nc8;SaeYZX:čB]1A߮@bG\7B/]Ft~<ctu'cSBۉٟ&ZFp[	 NO.>&l/?p#htSRMKLCgpsOZt5vU>[ԝݗT_ b\.~)nmuZX4цJi-f`?i~(d.0QfO؁^`HVGR '3bI5"%,NcX?Tf}rhP©ceh+)LVr??f;3kYq(GLu=KdA+3^˳mSħ_Vg_~W--I3ii2:uh٦U8õPdP#gSX~ĺt2DqbiTH>pU6uE3ca(6l&{zcq7R}:T]+	ѳ)^[@/O`Y"8,elĬW0"+*'YBi0<1y2؛1YcdR[LswI$qn"R$瘗;=%Y]J2G4!?Ya{7̸꺚H<^=mv84+1[EؼZ!-·),6@6,BD`D@bi,@wn
Kt	dtjF䩁siv?HVgZf ЛƨGEnU}lݒУcu0ӗp$l3 T*>\WZjLI\4tA:H1ٶX={8(۩? AC{;6;Nz3m\acizG,*׸`LW( TaaεwhP}QIq1=bkʺ$a҄N'=zInUSb[mxl<a1v$h)@Zk઒5,HdRx 8kRI,ψE#g"yRp"Y8P.rݱ s雋w@%z=-ʹܑoi7-	Ygzz34(zd1u ^{AC]"t囐8kf4;^!`ط&1$Bdؠ֞}9`.h Fi]&K SOXM;X׃guKjߎ*؉U|}[K$ɲ׺u0AG|Pm RXc0JáiQ+WTAI)6gm1^m&Uփkɱ-iK/'4$5#lV7(e@)R`l-M 2jI2 #!t=baJyX6H]{iGxT&9SNS¦樂ITho `H|*K1NRǶZpYqovW!7،/-%6A$l0	^2MW~^)8:?Tᯁd-  
jNdܭ+MW$z1H5kI`$0j}xG]@^0Ւ7PlX]56Ra1.'.A%:5	cH22ncdLC/+9싀ʑw{ux"[4֗A~֜y8`h2 ID:<>/q~-\\]Q[w؃Bt {X[[z4WrCcxRRKg,؅oe!@tMeqYY_fzzpC.,'/`oRsUz:\kC92m?Kxbw&\Q="
B3Rm$ZA8O,(WQU?EQ,>n'Ax3M-CukE.Sȧ>1y{23*:*ZD1:sdHEj~Fc)F%k	8>67	4_ZH*JϜ¨&A;=P?%Dk:|Ipn/вĩے 	0DW( \~j+XjF9cy7^E+ ,8kf6%Sߗ(Z6WBI4VwE{1m* _i2⭬ ygOaQV!?6]V8eM$n Vѡk`?S^(Md?A3X^XK1}4;0(#%(nS7P`$-O[;hCBf'h27w]ѥ'%>fܟnߒJ
e@(G\*ӃK1Sb+*W^K7!:L^_ǒU^Lx>FtOq#}uUYw#8D(e\L*HGiI56L\*y%tDCf[25\qtZ܀0jm]*"+XY}iwط@ekSH N[/@~|* 	<f
xiUWj rٞ׫`ExD2ćǒƁ	1~dΤ;GU_er{q_um	7m71ph4ZEчzÌ@rV@y-y3yE}OyG"[.:3da{ģX@qk;CnKqT9Uu9a'8wJӞ`+>̟xӀL$gw\)Aj7,kPdjpNjxS 0]qH:R"YZlJ9l{dc7pANZ6죦u3̱> r+sY|T)@]xHB,*8橸e$(ϟAUtk\4!-m#vWnIziЃNb|$ɮS8QlM.#O[Tn|
in~od^zGM+ #xREɍ쿵Ҹ1Jp~S,$Tp11ȕS	LT_I,DU::ÃnjPE{KһBת"z!T?!ڑ`ſ|`+1>݃!_"y1\)YttVCrnb@hl:=

5Uۑ)%"˾tNaa׏Le(*BN4}hU~].]!- tQt
|TMM5UI-w/3b2w .b R\;cx^`ǈ/~ш7nD}ß$4MAAX=Xi6ף5U3R6MXmi61fHK0)Q&0<+H#ʳ!Lo׈0vkqjJBG>:j֊GϓH	zW(nno-n5y-Et9s_{[~F>:S;SIx#jҢ7E35/)־mvO9 BG)HTrRጆtQYq LpzOmn>WŹ}犕&X<y#d&pY@ZXU԰1w;rǜX+Đ%g VB)ŜQRIjD~eǶ]SWgS?)Tf *J 1,fC>c*7Ff[rh=#d-jgEdd^X- m,zy~o5F^xC4WZpSh?iU4.Vc(3:0$-bhhPd,y5XĄD?kRjeMkASOͨ*R^K.4BuxhHj6uMVbf`0a̔(1~hFǢ׉fU8n91,F6]ό_NS
۰Q>YvH78kNmThEad!͂߸	N%_jYl9UO+\$
[iٴ;>|Ë%67+C$㨇ȷ}a'Gq	A1
g	-{8O&mug,/>deS7zLv`y(A0v_M7QmwOHCi?R̿զأdghsJYi%ژ)1+qޤH"Ksac*a&y<#'8s@,+3;KrX̋ewP&.u:"rc{3.n-DlknW7N/0;ڹ,5ul`;[25	d)$IzD/ЭS!?u:Ŭ؝
`3*+5@dowI
!B,["e.!߳%%jnF?Agҝ#29½ۺL!HuEޚr]Z"z.(9Z4aQ.?I}b<y`Fuɾpϧ<:ǣV-柍5=
U,8e{&f~\
ol4}]Z{2d^0Oi@&Y;z.Wzt"2^r1v@淬\_o	3N{,k]R6L=2U{_ J'Z,iU\ vi]JʬcjL*a@o`u;Iyj7&٫Y 5j.|zG6Ȩχ+IH#]uhd)pzUS'N*UҽuQYXa}?72'</a#Mup֕ne%(I?	}5вUx\NXGT$)yE}/B/us"ɫr
a{?uAg5[QيyNgijlRUeqցNx_C>n2V}D'}řВܡ1?4^˅ďeZN:TG]z,S>4Di`QdB╾7qw>e:KQ1]λyKg ]1 W)g1<R/c#h!i7хP6aHtߦ _ 	,xњɪqKy)Fh&Gqx¶4\MIV%(d`GHkD\8 5LQwHr5kEuݣr=PGa+jxE7ΚEpȼ͖"] Ϲ[pxNM#lBȩNPUvJpsKZhiћ|⋗k6;}!}U[$*i)pFC8pckj|7DܾsJ
ilWa,Pt2H  urIc*jXuyŘ]cbHϒ3ȈbY +!epS(5aa2`cۮx+hǩ~zO3m zfX3֡e1fuKR	vt3x-9RёEQN3M"Z22NFd{v[I6s{<Y|#Ez/<s!q-8)ôQ|1p?ҖT144]c(2QU<ƋdB_,rbB"Oܟ])5OzfTS\)x!L:<qo$h5t	Q&V+X_30efJz?Tx4dcI?*D ZgS/)mب,;b56Gu*ע^0fAo
Nsk/T,Ќ]6@PN'{
-	4hl~URQYņh
s!|qCv
ʇBƾl#Ɂ8퀠	o38-*?"57/p\k?O# ﻐ3 A\l0چڛ]!39 $,Ț'2#"{VfG&Ӎ^MZnjzGǩ]0&/튬.xrHuvD"/ 68do\Md0
ەXϺKӘZxTRIco-z&/E? PKH|l!BlKuN
h@1k	4YcH6hr*.k\p"nY:?Ln{z/Sኴw21yB1duk'%yp<1DNq>˻#6J7AI(mB";f؃zύy]m0%%atTw~ڥSJ usu*=`HKh#n-%"	9UnxPtMO/U@U^'C1"O͇lHL5}$/8݈TM5\EiԊL=QgsZR:D̨ M:?'/,aHǔf/ ׈Oמe=/XGT3S>&Y/$_PУHڜ-iXBXTvAr?x̋yTZSsKA6neʊ(%Va2W*l2pT-,̠3I`y6κE65o[ĜFk9miP:=I:T߹]\sY+s xqhNMt9	id^Zz|cD8&2yiK`PO{UGO
#ǜ* &{~	iL~[[k4!#)H[6reC\?|#//Kw'ha1Τ66|逖S\`'f	/H]?!<+9	[,F6DTUd:#A1?穒B0x@l^↍yΩym]s3\13Dl`
2c.[$6Qz	ʉZQ	Az'R4~mj0^E̮ "vk8JwD!As֣5gES13ES {ЉDrKlMޓ+ւZAZ5˄O{7o,z//%?C?9o1o\QĚO|J7"F۴6?Voq޵*jPs`ێ!B`ͪtG48nHiC5YT{4nǢ7hPGۤλ^w"u
7 p7P9;.ҿN_ pGLרT-R{o+|Mf&0e'DcnzHa21˱l1"qVA?ڽqD#iЙ#k@}$%C̍
oeQN2)<)mlєn#e'y7տUΘwQW	k'*]lIdL)30*f;/~n(W(z dl{?N6A
50cCM{
BAxE]&7	xյ=z#2w&/-v m}!pZQ~kON4.ץP]*a6 )"1s@@É̫犯Djgs1̻'v9T]5D8DS}kO2d%kxCy]a~O{NژŐqBciq0MfKbUP`Al@Y25x<eW҃'ѝEII|Y8.O=l0EE)dP$km잞 s?=t)96R=YӻMvaʇN<Ykd<A;-Z^S[Lj 9xP,EX9x+o pnb_tef,ߺ@ <ƊnlF9хѻ*%^w	F4$kXIHMԔR=N)?&ӯ\xZ2qT+;4Tލ}-FЭoYwG=;.*8p74GE+jkK~-ҨNpfӊ>xbhPb`N%77F*\O%]`"f266V+=<NMMtQJ&x.>٦ݢn٤FRƖj*B+R	 \AdxhҮ5BM0\hW|Ze!&\Kޕ;o
a=g{ӓ&bnr	~yĪʺ95	Vݗ&zsH֤К04odR\לN{Fv&֟kO(~ٍ_6$MɖV[(k&͞Rl	ҿ1![	>8@VJh6TiX 1{P\[G@Q8M n< gu<X0$l߳!>hc^-j2nE ]xH,%tp<̀dSDm@n1Htɩ'JbOORjL3O㭤_i )R[g	pA5/,YD*;w^!Y0DlD:_411u ?LzRQXqBy">kC-vw*Ew?5wr1.ћ&C؟5W} I"鲬u1;jSޒ@ǿH/MhtD"R/z%8QW.f!u߱Xa׿Xkjу-FW9V'u FCi,ndy.WY&<%Ϝ`C#e!%o2]SY*Vq~1t2DE{LH8(* *c,S/UrgH`s#@+>*$@9S0O:tCr#V`Akj\+(iTԿRb1 T`0RN2N&I'F	ഢ>f헯Bq*-{g@pQ; O]a\I:*2,$ל/CpuEX:ֈJ	chyw+zC\
_{yf(894g7m`"#a?Q^8	MxItP{AYi<m7v"8,A>͏
!K[E7?Ɔ~\6jOKX]/`DG5(FOX.RY0&~ؚMĆQ(rl mQB؞e_\tjow/5ξdYrfKN]%5qfGR).Jus(pS:')GTF>1ZDNx `IN		7
BԆg&JlDRy3aM!m#MTy˜/5<JV$t IHF~x18u6QN@Weǭ:,W8@]C^05ͷxj,0@lXfag>~ʘHeDsI9yݎ1d@C_;
ǥ_8gjk9e~NP<~Eȑ?'x!HmU} !n53ZiAސ%]أ!]SWW{b^ VM_ryu4>4Pq1{RSi@瑡fء!"}7Y ?'?4άm4r4Q-GZ¥g/,QٍWyB\ΛBH32EXLa{<78(]wg~xbhY.4 My%vԊmNGWa0bKRBg5CPYQhCa8ڲ=QEs~ ,ܔnFD_`b|zg%))*8s
%d.-`-X?6sPez^%d>߂+
'C&')3BxpB1
RȊœ.'/}aG1).-g
)f)`ug7״Qg∸DAY<}ӆ-2n[syvp2G0F|-c֗OTp"F 
ߏN~KhٚgX4_-K+(TԨ;%@_/*rt=;-ι#ql7؎GH_}]4xQf=_-&LEw2z))Kr7[紙H֏2=6VL<"n`1@+{gAUNdE]zTGbܔ,N2&WlRSWDԁ%u}X]A>HSNoYj~(?ª~)BM)\=Ɵ֌7hcW'ΤP;	SԹ),Ղ4ZW}fUp"%
At3Xn1)xOQϰ,o0mNT}P0#PʺD:[W0k"Bʸ/ 7)=/vjS`>b5)w.j]>֕zZZ'x *"!u=: &1@e=|1'I\;>WD1wʲ2sTy@RNTwQ?BkPhM!YO,؃CtGH*/݇m[^&MzD_|`X!'>u?YFg9QSۘFQ8" c3cυ@,* "!)EPU)2=(`UFnl]E6y'JZM1`j@{םU5)U4<SX+|Xkt7.UB]un\}xù*C`7cdv+<ZsnL^n#6~ƣIߴ?"Cv5;!RmB=tmӣ%xJ<G͗K騽v`#leGyl-K<*cSWY}2i7c$s:_g@c6rmI|5͓`ֺq~|^KQPC},*p-1iEb,ةyvN;ɘ| l!Ii\
a-p:.{亜౔@+|]Rq{]hZnJ%T%Z[70@/MgQq+65)c}\jƭ@vP=%2Wו[1̺E5~EM8H$}O9JDXӯLbU3luu4LLTdvf%qg6FiB55'pȃ5@	xi#;1BͿclITqRSy9[\#0}3[DPM6;zxul?!]bJCs_[7!g·+ā9ۻ [`4ĭNH^}o(PʯɃmae&O$Ѣ'
GFyv@MYa[W\zjf)PxiJt썹m	ɃLeQ/vg{*RMEn2㾈c!pt RۖsrMBZR\\̭qc`#H_aP6{	ca,nQ)Y33ZxBjASC<~	MA;bsvɐqu>VC1NV+}I_;5$rv^F57Qst,r^{ms i I2rۗrm%cLdiV-&mBgM:*C=SH ܤOn.$]K3NJk5Z,2U~mK,FW}ՠ@஢/͝97h0v1u޾rT:b`M4a+	7S䝶eRIx#β*d=7_`5'mn<EB4`{imwr] S
uz^IOLrwSQGH9bfS
)39Yl 2ȟezӝJoB>z(Eǽ3vU!k4pa%5
s٭Hǋ4<hmS,й#%ұtwk%M(Y<Q"bA^BGyl(]9gU%mI/Z~>oL2
zE;	\<A Xe'9p;QƷt"
8dz[\эI^:fy ޾6偨!83'rTC{&R|߽S4q>Չ`nu.rv,ߚe%Z'ߗ6%uI[HQnvF53LA[ee646R]18Tf`{6il48;üsnJgOߨjX(./l'
D&H''(ҙ^JS`Q1^3'XۓY#bΥ:`T"7bU>=Pvm%S}?6en4b{yO#~-QH9X''#x-Y%Dezuq0WG9,- 5xFd+&LcJ=Mh5eJ+wv4~MM*J#n _gb09P~[3NQˌ{8i	O³eꚶOB5jQsg?We!-R*uDWoi	^%6dFX*ÓkN4g
.bR/? aZЬ#'1@kzKW!O6`WGn'y$=F^da?Bwxx_w|Q_#[պt
i|4cC=q;_.s*1aGwMcl( +ߠ[{IVD&oR;q'NZ+RS%Z1U$RC-1=y4 W,X[/@EFpCw* G)Ļ^29g<8#Q>N:ˠ'Xd2٬ 5-6ie*hN=tMGWRMjyrk""ֲ	{Fv2|RJ';"~7VoW@2#5+*ў""oENw&*K^!oP,VnXB+#(1Հ=`DlHt%y(s>~ƶJmi_mjSLֺa\CaAsň7+,75&?^w*	Z|Va7Ni"OĿ\=`V(_q=&(,3M_:ЩPCGzsFU_ۓRݼMz9jx情OӭMJ% gt(ot{ ;@'[NɄ%C
U$Kk|VkXŽ:_朸Jk;~gz{DK|	: qSB60(gU֎Q UUئc?%V^T	L;p:w	X1MItb9{n-8U_?J\<24_z:VFf,|+;d^<3[4tӲ.S)gL^pEquvE3~'ԺZ%DfR^]`dVYsi`1k?ⵜ5fUgaL~F)J(Ll|v1*`6cڈi6ExUR̉w@GtbYߴ\_Өr4G,Yz~%囌ǽ5Dv\=um#9Oҟ⽰K,ihp`:Va5'q̨dSEܣ-@Aj.KrpCCdޢH5
-<l\DN[ڢvXm)&	e&l5tZx+ "]glhZx-b5S߸6f[V<:0۽Wr\y׋%+[:i,I,-2ʊ~{cXg.rIon6N3*j5μ1ۭm
oFV7{{Mp-6YL28/NZGjA6/IV 1@ӱv7vj~m Wϲ*e\eD$PT*>J^%
ӒѮn5$?/ixmeT5Nx*K]-!gnxfּ>kOP'!(0 ^dUTɅMkIo=J\B#{ܿK1d,ԍ4nفQI,7ǈ4Tu]/%pٿ;kyQvkVTv:tg2ih,A`%aq)h&XlTN G>cP,j(gjQ"&f#sO);N#eONG)XU
n>xiL \S\g7~݈BT93%#^5Z@"tyd4J$fVJ:Dx-gK2+C#럓g$?ϭ gdm`MFs=y^
Ahl#<*޺PE^`@h8R_ݘc)úda釤`xwa*whs˧^soZ*˽n6uof{slBf4(0BzglIϳc |l}aS<>*ʂ5]j	>^oYU#7g.V9}vk$H+^de+jΥ̑O遵ִTIe<%FH ӶBڷǰ7;a[B|1//̘q<a6<5/}M|ӌ?-G؋U|l*ځs- NSUPESt#>N[Mċ9x[tSE|ZMo4Rr"[m%jD~6r
'7E<Y3awSo^VV#uOf5ؔ[i@tV	5*,;JK99W1
*kΒW *ǠN2%\I=Q+94EٝAnW$r㶢Z.Rwk4cɄ>vHj[lAFT+n|(3_tp-(
L4J;оR^̪lmCHJ "8(*7P*Eh]f{}7;\V~3Y-m$S3a{ҫ?.Hߔ' 3DE/j󷆴-6#49&jnK	-Z\v+.U9m7X v]/ھ9C_t #UR6Yj$핡m6CӠi~>X]gPr/
*W~d2Q'Hp;]TRңܥemQLF3`~pf\-'Y'C8]ψccT5vgD6(w+;[Jx?*C\Hhv}Z9^YywΏqV7]ɮ Xԋs5/Y#
 i]7fe՛JBMzZӨǡ9?pQ~~ )1.:X6:c`0I{xc
R~ZJBFvapM	ņtBHdak߻Vjyv"Y_Ӝ?
wdE_Ll!xjMhY[^TN&uc[@"Ɨ`J^ 4=s[uEx3ۋ[,Hޯ8pQfc_~ZOơpt8mB/?[0&P"Hwrm##d];"AfG5^`鐳D-l"ER/E/V`7+S'QZA6/Ⱦ2{!qK-Y>P./nͫcUW~W8Y]7fY̓yvu)~liF`Yȡ:z66q$}#ه_jsStju--~t2?꺾^TFmwMt /"-vJ[G=t%z'G%1-0R,|cz14<[^m)63EtRpCs@5c/og~X8c99:B)cӹ"q`sL,l5Qǵ c[vS.?F7{ Q7ob,C8#=Yc&m5cT R'\]N7zuf:!wC_LaIz@ٵiЦOj]w2XCFn0I+rvPUNww)PgA, /VEF2&3M¡> ٠?1 ͖&9-ɞS$vҐިu>?0cNONqf7#P?1bb[YݘVǆ(&QǄI{(0$cLtM2-iK/.&"
Șh"E	i	n;K{1E-0ڌj$ik i}9└
 ҤaņbrIeޕoXC%_YTeGŧƏJfY^J9H(RL.۳yΌlF7ܝ,Oõ/{.OQ,!ؗ||jU3R")+Ŷy:RJf͚lz7@3Xle34|Exi_wLVHD,ϰg? NjR!'NFƞNHG|~_1%e3ü +~\eqww+ Ǿ6֗A*\<\š6(Ԧl%<9=%Fx	zX{Q|6V>y`׋29`AWؤDܑ=.o 
2zxrk>F P+wiB!nFFNy*v?:Exnik$,BÂ)8ZsBZuK&5nLz,- pC]OuPe( }I"*B	"_ uPf/V,I5.<p*aɘ !

88]_Kd-TWֵķX )R4#}vBvEƼnI#!Z쀐."i2]uyM0xK'Z㻓<R}O	.H)::uE6-|x/
J	Мq/|MWb i.`晿F>	HQFd%@&f̷T8!" 3L`2\y-*8͏	,67!|[(:ZUJP}[Q',hLbAG1<YcC;MR\cȪ?^)͕h})]>Raa@iJ7&fW4p!B.=RU/{tr	e]l`W~2L2H	"dE%ib\Gv^>kfXb.ǐ/M9h>n-5M08#iNz:*'e%
0v'WWƭp/|N
[-B$>{x""Ҿfn8"eRq.{z\ŗBp2#Q;9DوS3@h
<­rhWR4f&d	+`&Y@p`h»Zt'z-9 GK*V6&),N^;3{cs>9*NtΛeڰ!##쳹ƞ#boՓVo_(RG0UD@؃_Vg衼<$f,E${XgmXX9o|d`z;fSd5t
G$ fTkř.[,dۺ۪թiڣd׏e1Rmf
ߏ~ϥF9<|BL4J PJgѻL@$I|-D{d˟nCm |˹.W
Z%%p15'6Lş̦1JӨ(?)،q	7Aiם!Ȕ^~5Ϛh\e4I+9~9wrt,4cB`E9e{kÈ4E?ݨk2eg!JJ8;ǉ~]ր%kLݼ33ʘ )1G`yEu0	$oS/AVqZhdՌ#M#lB<fa[M$+L
h	O
҈}l$5"ELZ`yҨѻd9Rk(죰
C5<lhۛp[g"8d CfKF ]V_8cOTTR~'d*^;%Z-pMh>DMKog>pSQ-ܴE8!]Tf8 1\S5t[Uqn߹bpgdƫ0OH(z:	D$\V :1V5bή11gIdD1,2ETs)s`ԅx}҂0Ѱ_zmnmW<4ԏ}
?=է~6R=}dn{,ϘiʍdQ;ZhȢ(Yڙ}e{_-'W=o;Vo-fr9^C,"9ŸaZq(՘v@8ʌIiK.1(*K{nE2D/91!'pf宔ZzY}|TlӁ'~3
{Wlv7ZC]@XL23%=c*<iѱ$|uY[`Li"QM`3Ӕ6lTO{1SxkQ/tY}H 7nwyӵDZ h.{p('~Փ
W=ǖz4|6m?*Oa߬bCI4MDxʹ>I8!mfC!mc_C؉đ@v@PdE?kӿIg?(p{k?f7eYōXE`̾ݗikmhMT~]%PZ&O+Ԥ$o|A-&#Y;Z}Vl_z0~6f=9yJ{~EEk7}*H\+X
cIϸȃ	N$BAʦŒ\iV4t2-28&K!a?<dq90AfK;[F5 ۚ>ՍӋ=qE7/cv8zM`MYb
IҼ4?tTON1+v$LJ]B@nVfK9rla@ڸ`sяlЙt'ȽjLp/)㶮m!ӫmH~8&Rmw\Wk볻֠4&`;
b2{N7{'|aDXTˏsc`X~>xh]5!("Ud˥9gcdO;Cb(NY힉_8B)hG"&M_֞?`LcŇoxCVvαB(`pAm5̠\ B.-uF*;[%A"Klf)0S>}L}n^2҉stZ`f#{Zn.>2똚/Jq0:b?ANRaeZIzD֫s<1H<;|&_q'2JR#t8:CW?:(p0^:jmT鉓Jխ~tooorV!V-qύ:KXHS]7u%`[YI+Ƿ6mOl_lU4c#a9;U2sJ!qju˻KݜFrOqqCY3e(qbYETzs}w\{9$uD;e$g[0丌U<Ir!~q&$>wh9MWAFz;r!D#rٵi#l4Ud 5Kͣ*ѯ=Dآn5xo%FMp㝏DY?Įk5|TLWnEUʙkeL K}o0<xHڍh|t"Ժrsݷ)ȗ G8-zfjF\R^ڦIk}\}!-&Fli	&4
`i>Qy6ia&n-N0@<SiTR\ZQx]y5AuQX
6m4vMŭo2oswW#.sko/ޱS'[G`Pqr*)2w wR8ZZh4|~%7Ny)GCH_(EJnZ"ѐ.*k3D.Zox-ߍ8\RB_2[~'o$=".+ Hk\V]^1nzgW k{eR2|Jc"e9ܔ90JB~>iAMh6X7ض+a
qǂ>L?`@E`qbYca2=Ōuxg̴Y]RT¨|KTGtdQSLӾ2=௖+ٞDR?͜^/frqb\w
g0jjLx eF悤%UMLA%="83grWJ-i>>h*6^TW@=+biFH6Su	Zơ.}BTuJ,&l14Xt:Ϭ
-N~l(YYTiJc}Ύ	xͩQރ :>Y7¼Zt%-C 4ctĽP8#zʪP yC\LcM3W7ev~oox$&f"|\civsB/!DAr?ap;#!2pZzwlФZn0ifR`0[#V1)aZ?"|e0f_K򤵃6&F(XljbTs{,$bQR5/<ʕ0UN}jNVf>ISw}iu.|\1$g\gcAaZxeSBugI+yVus~AGR(g \ޥ-mx+{"˛@1bH;waZL|tTF'EڴcDj9"a*:R$O:͐OsR}.I! 7DȂr+Bp%MODDm\0`GBL[y^U'G}+K(I^XkPD}eB_by='IpD"M91n!,zGzYٞԻG*ҜK^!ъOv/KV"J5?HN]Sg!$r@+\6d!+ArwX
!D0_O8u{Ëؚ6UDfK. .{۹u:#뭒!ad2%دZ$r5#5f:	IQܡʮbk/kDDe9:j0=-N|?vjDL͗I)m|Ln'2O$%]ǡ<1Jgy5]WG2_yp%	A:zm~yUEy&/t6;x\sV?Y779[̸Ed%wn^9<'B6ZNySږat_	˰*\9%AԈO/n#By6NP	lv(Hn^8[1,MZjlOA>Tj1Swx{23-r\֪o$cp5";Yf׆ӷP]&,yR"ZIi6HBR$t!Q&O1ϸBvK?%k?#&qbW5`b>*+yVoK*2R$J|7m<$F4>pj99NBK#Eos=Z3Y5#.|)/m$5>Yؖki6ɊlS4b<ɴ0vHk'A4*tqCf({<YԚ:(,xP6&Y7йRĻ@9U~ةi䓭#0U9	껊N;B	nnV--zS4>?QS|bf<!/jD%7-ehH"t|7TM<ݖƀsUwX)Y!/jr?œ7Nf	 N.iUE.s7+wyA@YqQL>`%ıL2n%ux?^&L4W^zl0uqp8cAOOiT1|_0b:t3fڬrc)Y*aԎno%V*#:(A©vi_dWKFlێb"ٟfbP3oHg8Dsu1;3yV\5Jb5]<2sARڒ*~E&ʒ[xQENLH	v+^ִF4tIߌj+ B#$]:V`P>!*ĺj%kLIr
Flt,:	~gVSb`S+x*4౿UӞeGtA%^ZFV,]ait-Qr! 1(	_~O@%<MۏpXj;?j77PMaq3^r1O;zn[YP|ؗv"qd8908@zF;ڲh&/~
\wƞZMAYVi=Eqd֟gz2o%aoyAtՆ_pt<	.5)[m*_Pz=H|p1Ǩtpf([_l@ONÞ_QMj$ҩ:
>Vf3.1{07_Bи):C$Wͼh+]ANq	eRA(`X#/7?6Y\73LYyNBtȶyu"pC\10y^S&þ*#X@B41Oz2SS̊ݩ I 9S {RDq"dB!bYr=[X"P6.؜aaa#t&݉<rZ*#܋{ʸk[jTG])n=py5(>2/j1ꎂؼ̞IC_!'_#f(Z{G|jȣC|<hriX#;SΐXSVgbΥPIe'O&XXaěd2ސ sr
*'=aqP[M*"3%c=l~˺{VI0-&:ۅY
̡'eÔO#S[tŲV5`ۥ蟋O:ˤR6OPTX }c+*AyO_	Wog}m|H =U ?J"Ze):Uz$Ru,[囜UvKs s;Tg]	VVb`;0W-[:E؈eXΎqDLbwHazܠZD'.9R7'*@wS\\xVEe/Jtf Ue\{^	iю?{9.ck7ODyGl_	-kz}UPѮގ\H)A\vs<M@$%@w:CJkpzhuM,$ ^[ɟ~x8Qd1ӕ鼛tpuprZ#%8h>6v#]n&Dm
%"Nbi|ĚmW_,lKõ4dEZIB6)XAvTdZxFɵ[P T8z!WV^=z,GjME}Bap]t{nq[`l)*`w4*T܁J]k'7T))xIlg~ җ?JQEg4ڌ`:K&nwc@*;Wx5	EO'3
 Z'4ƪUWٕ; @^Y T,8(&XHj7ePOZP&v+CM=G88{O᧧4PQX`ܿ/`Xme1c:^3mVW,0jG77ߒC+Y kT;Ӵ/%#dJmmOn3g{{7\3GׂB<L+w.G )mICC?"EPesϭaH("'&$YܕRK/kZM:oF5UrX@pԮsF+|@VCwqKhb]`5	[fG|CG#M6:oN3rLֹM`1
셙<ErR߆*iϲ#F^sjsT/@{-#idM.04y,&9its\L pff峏313gp&g2*'5!5~Kl(ŧcTx_9'=Fќ|(Rmv;82)O8ʁV0=Hǟ|iyw4i;`yc-a%੫c߳H-@Ƿ<mm`j`k}Dr@˄itEd6/~u$g>s?T:J3-K/l6''OaOԯxv^y&OE]_Zw+Wa38yuiD/ b!F($١l+f^.CĠE'ոۄ2q up0c,.Ǟ&,׼oith!d[sǼ_tB]]@<gVcaQIbKL!I׃'zn
)f$ ,Ty?"rKR`܊ms	G-,(Qlΰp0:VWw'ִ-dzDܗ[T}v7P	DvSlOAl}5{/qNQC?گ5Ai>5!>=3+֊l4lPtgH%b)Q 1 R(evcHɤړ@',i0*H2o?_ /IӞ8CΚp00ؿN|$sTa_*Ua헩KZP:bx[Il1bOX_!էefTek)zZ_T'ۜ-1WY합z@}'ӎvt˄+ҥFS>GIj
}{oGTVn[GnnK|_t+qAՔ_4aչ9T}o놳@w+BMIvT̜`hWu2,g8J1|N;4=nP-y^~ZH^S Tۻݾ/ݫvR<yݢԴ VP:KSc4Uo.u/tHǃUFLW.e <X#6/ڂh5=z--hWuoG^.yA.R9m""^:Իf	(yT%5tЍ&Svح
nq/ax̊[:ﺈOt	xioF'I,_A_@2ah`ᏚD[͈K1B`Hrjȶcۈ`M"F! ';*φ@-@X#Rtڭ	pg**]@mQ.
=O#'>
+^0TÝg.)uu0tnj6|m;jVaL5*@N%Qw3P5
JK4tXWX~3'vsm |\QENY3:Eem5D8%_ˍ?UO`9%\+V
^Nfkcȃ@De iKVkPQê+M.Q{[ `M,C*8DFX	q,' =2fI](ޏ'a;ؕ~#L]as=Nq]S}lOO$5_0k,Lɱȷ=/6POJoYق,rphh\ƿՒq2$cu؂Hj̲ջ=[)s#\]kHIwXi[\ًC"8[$Cbf+]j5KE?X7`F@{Em f&칎{> Au;0ѥO*4.ZUŶ-Sң\>jxǣ&;N·''X Ɣ&rv=3~9M)E#CG#6u<{Pه݂4_&xW}wUN_eyf淹w 
rB=VߓPpl	Ob2ڂ?Z/6R&CLkr]Vhv>"6SdŃHn'ENxQ$J@<;ɋ{םGFqaPuZOQ^YOكN[VІ6D۰>]9e_1DNMJ2VPe?\+b6\aՓ'WT>Ũy"tu(SɈ0"rLi<4M"{4LJPkaE3J!c!}omBT:>M{dk޻Sz`JXcwƺwsBb:+h. |^Oo$an#AL@^Bw*@G^ A"YPnEصG#g|`zXAt,ܫ֟52c"Ո|ku>j^l/LChq_򱿣 6jyp,WFEl^IDWPWb~XvLۣ{f\<xjr$ΡАژ<6maJ?5w!Ҥ4)孲L;6q?iEtd,N%Nd
Db*O)RH?Fk0)tК#&#;\`{{9Bڅ?/5ay(i8ao8>}
L!6!)AvzbgqZNMlZk~	)6	{Z8A	V+0cmqovr	o8hd@NZuk`g4E'Ɖʹ74Mv0KG<W	#: ESsm}2@^LӋp{E_?j+`mG~C銒qtmeK<&0(wgx]5QHkC/'7
bH2ݐlj0+`'ڲ?|<
Xcdzr3;;sĪ
vq>Ϸdl_3$ |Zv-9[c"q5K0lP$+nYSi9׼/H.%2<]Oy`"3#HSL<6AY0'3XHBp.n(7a<}]K̓kѱ)cK0˺C~=I|J?R槫"@[qApSg]S-!!3/^?*i*Bbc]_PzE}G/[}dyB(E,$^q9zߕ34d>SbSdmNR[ADsΆd.tY@:tczAӆOS*"	9)i_E.5Y,C;0VAt[79ѭCtlXaŮQloHH֔U\1#
$7YRfڢC|vTNfq3POvK"UpLdL[;(N]|Wk  َhX{jE LvdTׅlEw]BAsT *,8JD>Iǋ>%5u-i.P@EwjUiT,>  \T*|cxёb\ו?U|*/âs%[</[%c<jFT~zQ_
<^׽ k<"8 iͽcBb5
V0Сemᡤo~BDF5^5ݫ	\4.^O=15FgecfW,o	)jx;}HxƘ'5hTƣ7	ȭi|_^M/PXr)@#$P 2JɖǞ.ˮ$:zMN8$px"4{
=ci/DlqU:c<X@Nr$
}~'Kdfzh@VfI|'(A9b<>sMG$񟧷]X9?|GڥYOOP蘩,[i&aN*+O,n봆jB[n	C`=b%1&opKlxo KPh2jNgk6*04NV:4a-LE+ ,_EtU6S9@D8kRƮEI|O)Dnfsa%o/pBv0)S<fɺ^;v(EtOuF0x~<]ۼ/p
{w!HщeМ*J2|1*ZaCaNzP]U9Nur&,ZM6;E,2349S8uAlkMYԼK5-kn^$ E)AZubfb)1DW*_"d7k۷T\hP.
2aqƒWn*ݗa*~y'3z?W5ZT~E'H||`=2	?̸Ws-p/XKbI6%i.nNL+:xոrI#/Y/p}TXgŚP!hȉAȎ 0@RKާ}`frXA0a>K1Rޚf =UʼV\rJ ׊p)YԟфP+x@U	J vqJoMVn4~$)aÈ@jR-,>QW>Iv 6Fpe|7KgC8)"la@zOr+X|o<W5'\N
X_Z]p6A*a2z}7KxkYc[(5ƝX1$juQ>lNfjIZP[BNctz!!>YFNTD
A,W~F0m.UO~cZUĐdLAp^n5/)IsGYB=ڿ>A.GUBPϽ*<Go\nBS <-0nY1ыb SM2V0l+/g=켋7&%17UFyp="9^&; l 1|]ꙅxGse-<_[UUQgG1#˳*)yuu\r?dj-,b>6	8m>YkZ-)2t>40;4pͿ;H1d*Ytlfl?ϋ,NT4u6}l־<O9 BtG)HT>R'a~J	Io	"->m*6ItIw}Z%Hi /?=zə\YNr*A6NyWkte"v*Hz*á'ygB!a6Ƿʢsl1W)gS?)Hf *J 1,fv>c*7M"ˢP@yEdD^X- m,zy~o5F^xC4WZpSh?iU4.Vc(3:0$-bhhPd,y5XĄD?kRjeMkASOͨ*R^K.4BuxhHj6uMVbf`0a̔(1~hFǢ׉fU8n91,F6]όONS
0Q>YvH78kNmTXE=ad!͂߸	N%_jYz=UO+\O >[ih>H궽5PB%6+C$㩇xȷBa'GqA1
g	,{nOTm➟u.w,I>@eEz-v
z(AYv1I/Umw;:*iX;kјdgi'sJ7ii%ژ)rxlϫ+qH"κKs3&<o#fJ8hsp@X+3KrXⶱewP0.}uJ"r-{V嚺._Dkw7/mBeΐZebf,*um`;[25Md)WIzbӕD_:!Pu:Ŭ؝Y}`3qڗG5dI~!/IukeZ!k܅Uvjn{FZ2gҝ2Ըˌ)!HEޚr]-Z"H.(ͭ[ޥZta#@?I}Yy`upaʆ:"D5tdx0,8
&5~|.
lo4]zZ2d ^1YOi!&ْ~;zGWoȂzr;Jt"@1rr^v@Υû\-o}3Nܬ{kp_RDLZ2o&{_ /'),~ϣi#8.vi]$ċ
jLC!o&;,ycR&ꊫ*fϜ5.ŜiNI:#}]JMU֮I&NXU˧%YX}?72'<Fa#Mwn%f?]}GU\cN3G%[yx&	y'/sK
P{u<AgiWng*j`R89Ɵnxg{>ԗ 5}D'(ER?7;ܪ˶!eZ-:čeGez,SmЉ>QDI`ݖQd-7@w=e:DKQ1]λyKg #i1 )41W<}0#7!'7񞅋P6u Itߦ!_ 8@	,ⴇd.ɪqKy-Fh$Gqx¶4\\MIWsuZdUyt)GvHɅkD\lr5iLQ͋wkHtrZk+uݣ  =Pa+fxўE7ӿ+pnͶ&] [p~M#4C^ƤNPUvvbJps#iښ߹[;c{!:[T*iLF58rckj|X)⽾3
lWa,ӼPt@Hˬo uICij7u軆/mkbHŧ3Ɉ$0 G!eΔSZbŋl523ݭc+j
zO^m.z	ɏ}Xd3e1fKR5{t2x-P>{E4=ZM"Z2`FdUD$[!I6CJ<Y_#E3/Rs!qC8)؟Q|b훁mZf1A43([QiU<SdB:, b-"?]_5ө#zfTS\)xa}!L:o~$5|}Q&v+X63Se	J	~KTX4dcIMK
:SmaSޱuvlSk&jok?ELVrC&_6zX5Vk\N߬`6t-[0lu㥝v8$O]vC/W݅6='?L8	aigbmN/mQV0Xv0(t]3 9Bɰ(	|7o) q~uh\Jb[udeXKX#(б"f`Ctya 2;hZa$:΄m;P,`CV4{Ud&:Zkj	ky(ԅMD;{a3iǇ]'/ذ-Pq{Tw~#?9rMPYrHs_iQfmB`v2m
p}&xD(V'ޗ"|voI\ z:=aA㕩(8;!#[{I|1#4l#)c_5I1i;WD$Mq;i>F<SI$Ǝ5Z1Y-c{ˌ{$h[/Ϭ
ʅ{O7$b
OxeB `YubJ9ބyֽwdvV>8yiM#'-OW&ܳiA,NW_-H9yAr谼u},"Bxo	BB{8⮼ps |~oyWA
/J[p?s)%~K{c)X"]<ΖQkop=i?;CEW|]~pV3w@J&C1|et)}AK=MCݬfLP+MMj*\	A/іZ=f8㚽4I-G`ߠhzm.B:`..wF/epEO*Z(8;ޮ<*Bg5>_(A<p;*0#c䤷˰]^+0%m#!QR;L	9W͹tDO	#9θy.G6O=^ƣ?G)P*p>O(լh~8{A4_m@/D>TB[J'ubiq dhr)A8Áw7#ꦪʈ*:+)^EvZR~,ʐ|]>KwCqg^ݿI)VxI\Wu;w2'a$YB\CBFW'9^ACrUϖwft4|~҉Yb \?-;PcTeDCBIϼMAhW j&S#C"/NLSAR! Ɔ4W+TqH}ffgzYil9}XI)FXr/=6B*A37pNݨqtA̎Ke`UozcTH:v	6q1D>(.87܉fa"};Ok8H9R4	F9IbtYlG9rf`tBi©I'k2@I?a?orY~Ёg2QAt+f-4R@۞JM]VmQ{f}V﵉r|U./;hȠLe:ycʳbG:dNLL+>x	V̉w@[%c[R\"h{n#&̈́$W@I
ɋ< WKi
亶'՗w]	AKQZߊpI59Բ+|ĮhHأ-P'hU7fy6v.bd3΃⸤Ļ%?&~- %oa V25t< rY|fb}6i:F%O=P*4~So>`z>vrumQogJuȊ`g*"bW=C#k{v
Sm&Ȗ8^gK6*lkϘi9X=g?֩@LwU_U8_=^U
9ǀe=g->M5|	S4}Q7vW)6WmMhBgF!p/x_BfOkݍJҰaxU%HwuOg~M6WVMbƟQ}ν`Y7Mhw.T6X*=cڙq	NQ⵷f9_q< }<*rj1c2u`9tG?)aZ%b\WO(NE쌕ЛUkbuMV.wƀmK#qAhUOoAXa<Q+J):,O4P`ʬ<Fhʙp\"`۽JofpE:ݣ@{&[ ~7@w%8$[Ίu25W D	7JnWbݗ~)4Πn(kq}`b:xR{Hf	fpQ%9":{e a_1P1{_fٔBU1t&\*Wvhd}]%) w .'AkӸ_ci3u)Ib,Z-(%qA7d%U#?bB lۜncVAHx8>Vla2q\<fӂ'	fLpFb]+c~W?۪۬
ƹ5(8&OMSn*j҇[@٨-ND5w>mJ%P+ZxI+|Ρbā?7V]<V*43|tq8%Fؼf?2Xǅg*ܵEH&M 4ˮx[chK"XAZ7BC *Wrbm=wT8%*V@X?PF(apaIK3{s.Fb_CwR}.mte0;\־A*
s&$Ƃiu:Rd
7&)>K,{߹3h3YV*ykn`B1LA>9u:F$J#ۑYTq
M1&-DTO,&И$)$F!ƄyK3pKX9(8[v~]R%,C
hutuH_;"9i]Iւs[Bϫò.R	nt}$ܧ5*C|8H Q9;'>c}Tɬ塜)4n,3DK>icQqr*fTw'U+AOZ7冐}EIV(-w`7<֙aX9,s4`bʹb/	$Ħ44=  !Fo|ţYC	5OQc&1NµڹKK8fè!c$9
Z%g|>K-ȝ|!.	d^RS\։pY v2$ԎUFi69]Q0kUttvACz)>DnZT?砃~#kFxSHd	Z7;D i=urhoyt=1%X`SꌸR<6yڋp52a0	R+ϑ$ {Mz9BN:B^IY50#Zm՜H$|G˜@!#Lq{7̸ʓd6$$S=ʪ7ޱ0|>w\([